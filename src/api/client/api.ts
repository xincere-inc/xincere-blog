/* tslint:disable */
/* eslint-disable */
/**
 * Next.js API
 * API documentation for Next.js 15 application
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AdminCreateCategory201Response
 */
export interface AdminCreateCategory201Response {
    /**
     * 
     * @type {string}
     * @memberof AdminCreateCategory201Response
     */
    'message'?: string;
    /**
     * 
     * @type {AdminCreateCategory201ResponseCategory}
     * @memberof AdminCreateCategory201Response
     */
    'category'?: AdminCreateCategory201ResponseCategory;
}
/**
 * 
 * @export
 * @interface AdminCreateCategory201ResponseCategory
 */
export interface AdminCreateCategory201ResponseCategory {
    /**
     * The unique identifier for the category.
     * @type {number}
     * @memberof AdminCreateCategory201ResponseCategory
     */
    'id'?: number;
    /**
     * The name of the category.
     * @type {string}
     * @memberof AdminCreateCategory201ResponseCategory
     */
    'name'?: string;
    /**
     * The unique slug for the category.
     * @type {string}
     * @memberof AdminCreateCategory201ResponseCategory
     */
    'slug'?: string;
    /**
     * The description of the category (optional).
     * @type {string}
     * @memberof AdminCreateCategory201ResponseCategory
     */
    'description'?: string | null;
    /**
     * The date and time when the category was created.
     * @type {string}
     * @memberof AdminCreateCategory201ResponseCategory
     */
    'createdAt'?: string;
    /**
     * The date and time when the category was last updated.
     * @type {string}
     * @memberof AdminCreateCategory201ResponseCategory
     */
    'updatedAt'?: string;
    /**
     * The date and time when the category was deleted (optional).
     * @type {string}
     * @memberof AdminCreateCategory201ResponseCategory
     */
    'deletedAt'?: string | null;
}
/**
 * 
 * @export
 * @interface AdminCreateCategory400Response
 */
export interface AdminCreateCategory400Response {
    /**
     * 
     * @type {string}
     * @memberof AdminCreateCategory400Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface AdminCreateCategoryRequest
 */
export interface AdminCreateCategoryRequest {
    /**
     * The name of the category.
     * @type {string}
     * @memberof AdminCreateCategoryRequest
     */
    'name': string;
    /**
     * The unique slug for the category.
     * @type {string}
     * @memberof AdminCreateCategoryRequest
     */
    'slug': string;
    /**
     * The description of the category (optional).
     * @type {string}
     * @memberof AdminCreateCategoryRequest
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface AdminCreateTag201Response
 */
export interface AdminCreateTag201Response {
    /**
     * 
     * @type {string}
     * @memberof AdminCreateTag201Response
     */
    'message'?: string;
    /**
     * 
     * @type {AdminCreateTag201ResponseTag}
     * @memberof AdminCreateTag201Response
     */
    'tag'?: AdminCreateTag201ResponseTag;
}
/**
 * 
 * @export
 * @interface AdminCreateTag201ResponseTag
 */
export interface AdminCreateTag201ResponseTag {
    /**
     * The unique identifier for the tag.
     * @type {number}
     * @memberof AdminCreateTag201ResponseTag
     */
    'id'?: number;
    /**
     * The name of the tag.
     * @type {string}
     * @memberof AdminCreateTag201ResponseTag
     */
    'name'?: string;
    /**
     * The date and time when the tag was created.
     * @type {string}
     * @memberof AdminCreateTag201ResponseTag
     */
    'createdAt'?: string;
    /**
     * The date and time when the tag was last updated.
     * @type {string}
     * @memberof AdminCreateTag201ResponseTag
     */
    'updatedAt'?: string;
    /**
     * The date and time when the tag was deleted (optional).
     * @type {string}
     * @memberof AdminCreateTag201ResponseTag
     */
    'deletedAt'?: string | null;
}
/**
 * 
 * @export
 * @interface AdminCreateTag400Response
 */
export interface AdminCreateTag400Response {
    /**
     * 
     * @type {string}
     * @memberof AdminCreateTag400Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface AdminCreateTagRequest
 */
export interface AdminCreateTagRequest {
    /**
     * The unique name of the tag.
     * @type {string}
     * @memberof AdminCreateTagRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface AdminCreateUser400Response
 */
export interface AdminCreateUser400Response {
    /**
     * 
     * @type {string}
     * @memberof AdminCreateUser400Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface AdminCreateUserRequest
 */
export interface AdminCreateUserRequest {
    /**
     * 
     * @type {string}
     * @memberof AdminCreateUserRequest
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof AdminCreateUserRequest
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof AdminCreateUserRequest
     */
    'country': string;
    /**
     * 
     * @type {string}
     * @memberof AdminCreateUserRequest
     */
    'gender'?: AdminCreateUserRequestGenderEnum;
    /**
     * 
     * @type {string}
     * @memberof AdminCreateUserRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof AdminCreateUserRequest
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof AdminCreateUserRequest
     */
    'phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminCreateUserRequest
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminCreateUserRequest
     */
    'role'?: string;
}

export const AdminCreateUserRequestGenderEnum = {
    Male: 'male',
    Female: 'female',
    Other: 'other'
} as const;

export type AdminCreateUserRequestGenderEnum = typeof AdminCreateUserRequestGenderEnum[keyof typeof AdminCreateUserRequestGenderEnum];

/**
 * 
 * @export
 * @interface AdminCreateArticleRequest
 */
export interface AdminCreateArticleRequest {
  /**
   * ID of the author creating the article
   * 
   * @type {string}
   * @memberof AdminCreateArticleRequest
   */
  'authorId': string;

  /**
   * ID of the category this article belongs to
   * 
   * @type {number}
   * @memberof AdminCreateArticleRequest
   */
  'categoryId': number;

  /**
   * Title of the article
   * 
   * @type {string}
   * @memberof AdminCreateArticleRequest
   */
  'title': string;

  /**
   * Slug (URL-friendly identifier for the article)
   * 
   * @type {string}
   * @memberof AdminCreateArticleRequest
   */
  'slug': string;

  /**
   * Short summary or excerpt of the article
   * 
   * @type {string}
   * @memberof AdminCreateArticleRequest
   */
  'summary': string;

  /**
   * Full HTML content of the article
   * 
   * @type {string}
   * @memberof AdminCreateArticleRequest
   */
  'content': string;

  /**
   * Raw markdown version of the content
   * 
   * @type {string}
   * @memberof AdminCreateArticleRequest
   */
  'markdownContent': string;

  /**
   * Status of the article (e.g., draft, published)
   * 
   * @type {string}
   * @memberof AdminCreateArticleRequest
   */
  'status': string;

  /**
   * Optional thumbnail image URL
   * 
   * @type {string}
   * @memberof AdminCreateArticleRequest
   */
  'thumbnailUrl'?: string;

  /**
   * Optional list of tag IDs associated with the article
   * 
   * @type {number[]}
   * @memberof AdminCreateArticleRequest
   */
  'tags'?: number[];
}

/**
 * 
 * @export
 * @interface AdminDeleteCategoriesRequest
 */
export interface AdminDeleteCategoriesRequest {
    /**
     * 
     * @type {Array<number>}
     * @memberof AdminDeleteCategoriesRequest
     */
    'ids': Array<number>;
}
/**
 * 
 * @export
 * @interface AdminDeleteUsersRequest
 */
export interface AdminDeleteUsersRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof AdminDeleteUsersRequest
     */
    'ids': Array<string>;
}
/**
 * 
 * @export
 * @interface AdminDeleteArticlesRequest
 */
export interface AdminDeleteArticlesRequest {
  /**
   * A list of article IDs to delete.
   * @type {number[]}
   * @memberof AdminDeleteArticlesRequest
   */
  'articleIds': number[];
}

/**
 * 
 * @export
 * @interface AdminGetCategories200Response
 */
export interface AdminGetCategories200Response {
    /**
     * 
     * @type {Array<AdminGetCategories200ResponseDataInner>}
     * @memberof AdminGetCategories200Response
     */
    'data'?: Array<AdminGetCategories200ResponseDataInner>;
    /**
     * 
     * @type {AdminGetCategories200ResponsePagination}
     * @memberof AdminGetCategories200Response
     */
    'pagination'?: AdminGetCategories200ResponsePagination;
}
/**
 * 
 * @export
 * @interface AdminGetCategories200ResponseDataInner
 */
export interface AdminGetCategories200ResponseDataInner {
    /**
     * The unique identifier for the category.
     * @type {number}
     * @memberof AdminGetCategories200ResponseDataInner
     */
    'id'?: number;
    /**
     * The name of the category.
     * @type {string}
     * @memberof AdminGetCategories200ResponseDataInner
     */
    'name'?: string;
    /**
     * The unique slug for the category.
     * @type {string}
     * @memberof AdminGetCategories200ResponseDataInner
     */
    'slug'?: string;
    /**
     * The description of the category (optional).
     * @type {string}
     * @memberof AdminGetCategories200ResponseDataInner
     */
    'description'?: string | null;
    /**
     * The date and time when the category was created.
     * @type {string}
     * @memberof AdminGetCategories200ResponseDataInner
     */
    'createdAt'?: string;
    /**
     * The date and time when the category was last updated.
     * @type {string}
     * @memberof AdminGetCategories200ResponseDataInner
     */
    'updatedAt'?: string;
    /**
     * The date and time when the category was deleted (optional).
     * @type {string}
     * @memberof AdminGetCategories200ResponseDataInner
     */
    'deletedAt'?: string | null;
}
/**
 * 
 * @export
 * @interface AdminGetCategories200ResponsePagination
 */
export interface AdminGetCategories200ResponsePagination {
    /**
     * 
     * @type {number}
     * @memberof AdminGetCategories200ResponsePagination
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminGetCategories200ResponsePagination
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminGetCategories200ResponsePagination
     */
    'showPerPage'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminGetCategories200ResponsePagination
     */
    'totalCategories'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminGetCategories200ResponsePagination
     */
    'totalPages'?: number;
}
/**
 * 
 * @export
 * @interface AdminGetTags200Response
 */
export interface AdminGetTags200Response {
    /**
     * 
     * @type {Array<AdminCreateTag201ResponseTag>}
     * @memberof AdminGetTags200Response
     */
    'data'?: Array<AdminCreateTag201ResponseTag>;
    /**
     * 
     * @type {AdminGetTags200ResponsePagination}
     * @memberof AdminGetTags200Response
     */
    'pagination'?: AdminGetTags200ResponsePagination;
}
/**
 * 
 * @export
 * @interface AdminGetTags200ResponsePagination
 */
export interface AdminGetTags200ResponsePagination {
    /**
     * 
     * @type {number}
     * @memberof AdminGetTags200ResponsePagination
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminGetTags200ResponsePagination
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminGetTags200ResponsePagination
     */
    'showPerPage'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminGetTags200ResponsePagination
     */
    'totalTags'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminGetTags200ResponsePagination
     */
    'totalPages'?: number;
}
/**
 * 
 * @export
 * @interface AdminGetUsers200Response
 */
export interface AdminGetUsers200Response {
    /**
     * 
     * @type {Array<AdminGetUsers200ResponseDataInner>}
     * @memberof AdminGetUsers200Response
     */
    'data'?: Array<AdminGetUsers200ResponseDataInner>;
    /**
     * 
     * @type {AdminGetUsers200ResponsePagination}
     * @memberof AdminGetUsers200Response
     */
    'pagination'?: AdminGetUsers200ResponsePagination;
}
/**
 * 
 * @export
 * @interface AdminGetUsers200ResponseDataInner
 */
export interface AdminGetUsers200ResponseDataInner {
    /**
     * 
     * @type {string}
     * @memberof AdminGetUsers200ResponseDataInner
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminGetUsers200ResponseDataInner
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminGetUsers200ResponseDataInner
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminGetUsers200ResponseDataInner
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminGetUsers200ResponseDataInner
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminGetUsers200ResponseDataInner
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminGetUsers200ResponseDataInner
     */
    'phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminGetUsers200ResponseDataInner
     */
    'role'?: string;
}
/**
 * 
 * @export
 * @interface AdminGetUsers200ResponsePagination
 */
export interface AdminGetUsers200ResponsePagination {
    /**
     * 
     * @type {number}
     * @memberof AdminGetUsers200ResponsePagination
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminGetUsers200ResponsePagination
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminGetUsers200ResponsePagination
     */
    'showPerPage'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminGetUsers200ResponsePagination
     */
    'totalUsers'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminGetUsers200ResponsePagination
     */
    'totalPages'?: number;
}
/**
 * 
 * @export
 * @interface AdminGetUsers400Response
 */
export interface AdminGetUsers400Response {
    /**
     * 
     * @type {string}
     * @memberof AdminGetUsers400Response
     */
    'error'?: string;
    /**
     * 
     * @type {Array<AdminGetUsers400ResponseErrorsInner>}
     * @memberof AdminGetUsers400Response
     */
    'errors'?: Array<AdminGetUsers400ResponseErrorsInner>;
}
/**
 * 
 * @export
 * @interface AdminGetUsers400ResponseErrorsInner
 */
export interface AdminGetUsers400ResponseErrorsInner {
    /**
     * 
     * @type {string}
     * @memberof AdminGetUsers400ResponseErrorsInner
     */
    'path'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminGetUsers400ResponseErrorsInner
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface AdminGetUsersRequest
 */
export interface AdminGetUsersRequest {
    /**
     * 
     * @type {number}
     * @memberof AdminGetUsersRequest
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminGetUsersRequest
     */
    'limit'?: number;
    /**
     * 
     * @type {string}
     * @memberof AdminGetUsersRequest
     */
    'search'?: string;
}
/**
 * 
 * @export
 * @interface AdminGetArticlesRequest
 */
export interface AdminGetArticlesRequest {
    /**
     * 
     * @type {number}
     * @memberof AdminGetArticlesRequest
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminGetArticlesRequest
     */
    'limit'?: number;
    /**
     * 
     * @type {string}
     * @memberof AdminGetArticlesRequest
     */
    'search'?: string;
}
/**
 * 
 * @export
 * @interface AdminGetArticles200Response
 */
export interface AdminGetArticles200Response {
    /**
     * 
     * @type {Array<AdminGetArticles200ResponseDataInner>}
     * @memberof AdminGetArticles200Response
     */
    'data'?: Array<AdminGetArticles200ResponseDataInner>;
    /**
     * 
     * @type {AdminGetArticles200ResponsePagination}
     * @memberof AdminGetArticles200Response
     */
    'pagination'?: AdminGetArticles200ResponsePagination;
}
/**
 * 
 * @export
 * @interface AdminGetArticles200ResponseDataInner
 */
export interface AdminGetArticles200ResponseDataInner {
    /**
     * 
     * @type {number}
     * @memberof AdminGetArticles200ResponseDataInner
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof AdminGetArticles200ResponseDataInner
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminGetArticles200ResponseDataInner
     */
    'slug'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminGetArticles200ResponseDataInner
     */
    'summary'?: string;
     /**
     * 
     * @type {string}
     * @memberof AdminGetArticles200ResponseDataInner
     */
    'content'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminGetArticles200ResponseDataInner
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminGetArticles200ResponseDataInner
     */
    'thumbnailUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminGetArticles200ResponseDataInner
     */
    author?: {
        name: string;
        [key: string]: any;
    };
    /**
     * 
     * @type {string}
     * @memberof AdminGetArticles200ResponseDataInner
     */
    category?: {
        name: string;
        [key: string]: any;
    };
    /**
     * 
     * @type {Array<string>}
     * @memberof AdminGetArticles200ResponseDataInner
     */
    'tags'?: string[];
    /**
     * 
     * @type {string}
     * @memberof AdminGetArticles200ResponseDataInner
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminGetArticles200ResponseDataInner
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface AdminGetArticles200ResponsePagination
 */
export interface AdminGetArticles200ResponsePagination {
    /**
     * 
     * @type {number}
     * @memberof AdminGetArticles200ResponsePagination
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminGetArticles200ResponsePagination
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminGetArticles200ResponsePagination
     */
    'showPerPage'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminGetArticles200ResponsePagination
     */
    'totalArticles'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminGetArticles200ResponsePagination
     */
    'totalPages'?: number;
}
/**
 * 
 * @export
 * @interface AdminGetArticles400Response
 */
export interface AdminGetArticles400Response {
    /**
     * 
     * @type {string}
     * @memberof AdminGetArticles400Response
     */
    'error'?: string;
    /**
     * 
     * @type {Array<AdminGetArticles400ResponseErrorsInner>}
     * @memberof AdminGetArticles400Response
     */
    'errors'?: Array<AdminGetArticles400ResponseErrorsInner>;
}
/**
 * 
 * @export
 * @interface AdminGetArticles400ResponseErrorsInner
 */
export interface AdminGetArticles400ResponseErrorsInner {
    /**
     * 
     * @type {string}
     * @memberof AdminGetArticles400ResponseErrorsInner
     */
    'path'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminGetArticles400ResponseErrorsInner
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface AdminGetAuthorsRequest
 */
export interface AdminGetAuthorsRequest {
    /**
     * 
     * @type {number}
     * @memberof AdminGetAuthorsRequest
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminGetAuthorsRequest
     */
    'limit'?: number;
    /**
     * 
     * @type {string}
     * @memberof AdminGetAuthorsRequest
     */
    'search'?: string;
}
/**
 * 
 * @export
 * @interface AdminGetAuthors200Response
 */
export interface AdminGetAuthors200Response {
    /**
     * 
     * @type {Array<AdminGetAuthors200ResponseDataInner>}
     * @memberof AdminGetAuthors200Response
     */
    'data'?: Array<AdminGetAuthors200ResponseDataInner>;
    /**
     * 
     * @type {AdminGetAuthors200ResponsePagination}
     * @memberof AdminGetAuthors200Response
     */
    'pagination'?: AdminGetAuthors200ResponsePagination;
}
/**
 * 
 * @export
 * @interface AdminGetAuthors200ResponseDataInner
 */
export interface AdminGetAuthors200ResponseDataInner {
  /**
   * 
   * @type {string}
   * @memberof AdminGetAuthors200ResponseDataInner
   */
  id: string;

  /**
   * 
   * @type {string}
   * @memberof AdminGetAuthors200ResponseDataInner
   */
  name: string;

  /**
   * 
   * @type {string}
   * @memberof AdminGetAuthors200ResponseDataInner
   */
  title: string;

  /**
   * 
   * @type {string}
   * @memberof AdminGetAuthors200ResponseDataInner
   */
  bio: string;

  /**
   * 
   * @type {string}
   * @memberof AdminGetAuthors200ResponseDataInner
   */
  avatarUrl: string;

  /**
   * 
   * @type {string}
   * @memberof AdminGetAuthors200ResponseDataInner
   */
  createdAt: string;

  /**
   * 
   * @type {string}
   * @memberof AdminGetAuthors200ResponseDataInner
   */
  updatedAt: string;
}

/**
 * 
 * @export
 * @interface AdminGetAuthors200ResponsePagination
 */
export interface AdminGetAuthors200ResponsePagination {
    /**
     * 
     * @type {number}
     * @memberof AdminGetAuthors200ResponsePagination
     */
    'totalAuthors': number;

    /**
     * 
     * @type {number}
     * @memberof AdminGetAuthors200ResponsePagination
     */
    'currentPage': number;

    /**
     * 
     * @type {number}
     * @memberof AdminGetAuthors200ResponsePagination
     */
    'totalPages': number;
}



/**
 * 
 * @export
 * @interface AdminUpdateCategory200Response
 */
export interface AdminUpdateCategory200Response {
    /**
     * 
     * @type {string}
     * @memberof AdminUpdateCategory200Response
     */
    'message'?: string;
    /**
     * 
     * @type {AdminCreateCategory201ResponseCategory}
     * @memberof AdminUpdateCategory200Response
     */
    'category'?: AdminCreateCategory201ResponseCategory;
}
/**
 * 
 * @export
 * @interface AdminUpdateCategoryRequest
 */
export interface AdminUpdateCategoryRequest {
    /**
     * The ID of the category to update.
     * @type {number}
     * @memberof AdminUpdateCategoryRequest
     */
    'id': number;
    /**
     * The name of the category.
     * @type {string}
     * @memberof AdminUpdateCategoryRequest
     */
    'name'?: string;
    /**
     * The unique slug for the category.
     * @type {string}
     * @memberof AdminUpdateCategoryRequest
     */
    'slug'?: string;
    /**
     * The description of the category (optional).
     * @type {string}
     * @memberof AdminUpdateCategoryRequest
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface AdminUpdateTag200Response
 */
export interface AdminUpdateTag200Response {
    /**
     * 
     * @type {string}
     * @memberof AdminUpdateTag200Response
     */
    'message'?: string;
    /**
     * 
     * @type {AdminCreateTag201ResponseTag}
     * @memberof AdminUpdateTag200Response
     */
    'tag'?: AdminCreateTag201ResponseTag;
}
/**
 * 
 * @export
 * @interface AdminUpdateTagRequest
 */
export interface AdminUpdateTagRequest {
    /**
     * The ID of the tag to update.
     * @type {number}
     * @memberof AdminUpdateTagRequest
     */
    'id': number;
    /**
     * The name of the tag.
     * @type {string}
     * @memberof AdminUpdateTagRequest
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface AdminUpdateUser200Response
 */
export interface AdminUpdateUser200Response {
    /**
     * 
     * @type {string}
     * @memberof AdminUpdateUser200Response
     */
    'message'?: string;
    /**
     * 
     * @type {AdminUpdateUser200ResponseUser}
     * @memberof AdminUpdateUser200Response
     */
    'user'?: AdminUpdateUser200ResponseUser;
}
/**
 * 
 * @export
 * @interface AdminUpdateUser200ResponseUser
 */
export interface AdminUpdateUser200ResponseUser {
    /**
     * 
     * @type {string}
     * @memberof AdminUpdateUser200ResponseUser
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminUpdateUser200ResponseUser
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminUpdateUser200ResponseUser
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminUpdateUser200ResponseUser
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminUpdateUser200ResponseUser
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminUpdateUser200ResponseUser
     */
    'phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminUpdateUser200ResponseUser
     */
    'role'?: AdminUpdateUser200ResponseUserRoleEnum;
    /**
     * 
     * @type {string}
     * @memberof AdminUpdateUser200ResponseUser
     */
    'country'?: string;
}

export const AdminUpdateUser200ResponseUserRoleEnum = {
    User: 'USER',
    Admin: 'ADMIN'
} as const;

export type AdminUpdateUser200ResponseUserRoleEnum = typeof AdminUpdateUser200ResponseUserRoleEnum[keyof typeof AdminUpdateUser200ResponseUserRoleEnum];

/**
 * 
 * @export
 * @interface AdminUpdateUser400Response
 */
export interface AdminUpdateUser400Response {
    /**
     * 
     * @type {string}
     * @memberof AdminUpdateUser400Response
     */
    'error'?: string;
    /**
     * 
     * @type {Array<AdminUpdateUser400ResponseErrorsInner>}
     * @memberof AdminUpdateUser400Response
     */
    'errors'?: Array<AdminUpdateUser400ResponseErrorsInner>;
}
/**
 * 
 * @export
 * @interface AdminUpdateUser400ResponseErrorsInner
 */
export interface AdminUpdateUser400ResponseErrorsInner {
    /**
     * 
     * @type {string}
     * @memberof AdminUpdateUser400ResponseErrorsInner
     */
    'path'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminUpdateUser400ResponseErrorsInner
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface AdminUpdateUser404Response
 */
export interface AdminUpdateUser404Response {
    /**
     * 
     * @type {string}
     * @memberof AdminUpdateUser404Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface AdminUpdateUser500Response
 */
export interface AdminUpdateUser500Response {
    /**
     * 
     * @type {string}
     * @memberof AdminUpdateUser500Response
     */
    'error'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminUpdateUser500Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface AdminUpdateUserRequest
 */
export interface AdminUpdateUserRequest {
    /**
     * The ID of the user to update.
     * @type {string}
     * @memberof AdminUpdateUserRequest
     */
    'id': string;
    /**
     * The email address of the user.
     * @type {string}
     * @memberof AdminUpdateUserRequest
     */
    'email'?: string;
    /**
     * The first name of the user.
     * @type {string}
     * @memberof AdminUpdateUserRequest
     */
    'firstName'?: string;
    /**
     * The last name of the user.
     * @type {string}
     * @memberof AdminUpdateUserRequest
     */
    'lastName'?: string;
    /**
     * The address of the user.
     * @type {string}
     * @memberof AdminUpdateUserRequest
     */
    'address'?: string;
    /**
     * The phone number of the user.
     * @type {string}
     * @memberof AdminUpdateUserRequest
     */
    'phone'?: string;
    /**
     * The role of the user.
     * @type {string}
     * @memberof AdminUpdateUserRequest
     */
    'role'?: AdminUpdateUserRequestRoleEnum;
    /**
     * The country of the user.
     * @type {string}
     * @memberof AdminUpdateUserRequest
     */
    'country'?: string;
}

export const AdminUpdateUserRequestRoleEnum = {
    User: 'user',
    Admin: 'admin'
} as const;

export type AdminUpdateUserRequestRoleEnum = typeof AdminUpdateUserRequestRoleEnum[keyof typeof AdminUpdateUserRequestRoleEnum];

/**
 * 
 * @export
 * @interface AdminUpdateArticleRequest
 */
export interface AdminUpdateArticleRequest {
    /**
     * The ID of the article to update.
     * @type {number}
     * @memberof AdminUpdateArticleRequest
     */
    'id': number;

    /**
     * The title of the article.
     * @type {string}
     * @memberof AdminUpdateArticleRequest
     */
    'title'?: string;

    /**
     * The slug of the article.
     * @type {string}
     * @memberof AdminUpdateArticleRequest
     */
    'slug'?: string;

    /**
     * The summary of the article.
     * @type {string}
     * @memberof AdminUpdateArticleRequest
     */
    'summary'?: string;

    /**
     * The content of the article in HTML.
     * @type {string}
     * @memberof AdminUpdateArticleRequest
     */
    'content'?: string;

    /**
     * The markdown content of the article.
     * @type {string}
     * @memberof AdminUpdateArticleRequest
     */
    'markdownContent'?: string;

    /**
     * The status of the article.
     * @type {AdminUpdateArticleRequestStatusEnum}
     * @memberof AdminUpdateArticleRequest
     */
    'status'?: AdminUpdateArticleRequestStatusEnum;

    /**
     * The ID of the author of the article.
     * @type {string}
     * @memberof AdminUpdateArticleRequest
     */
    'authorId'?: string;

    /**
     * The ID of the category the article belongs to.
     * @type {number}
     * @memberof AdminUpdateArticleRequest
     */
    'categoryId'?: number;

    /**
     * The URL of the article's thumbnail.
     * @type {string}
     * @memberof AdminUpdateArticleRequest
     */
    'thumbnailUrl'?: string;

    /**
     * The tag IDs associated with the article.
     * @type {number[]}
     * @memberof AdminUpdateArticleRequest
     */
    'tagIds'?: number[];
}

export const AdminUpdateArticleRequestStatusEnum = {
    Draft: 'draft',
    Published: 'published',
    Archived: 'archived'
} as const;

export type AdminUpdateArticleRequestStatusEnum = typeof AdminUpdateArticleRequestStatusEnum[keyof typeof AdminUpdateArticleRequestStatusEnum];

/**
 * 
 * @export
 * @interface AdminUpdateArticle200Response
 */
export interface AdminUpdateArticle200Response {
    /**
     * 
     * @type {string}
     * @memberof AdminUpdateArticle200Response
     */
    'message'?: string;

    /**
     * 
     * @type {AdminUpdateArticle200ResponseArticle}
     * @memberof AdminUpdateArticle200Response
     */
    'article'?: AdminUpdateArticle200ResponseArticle;
}
/**
 * 
 * @export
 * @interface AdminUpdateArticle200ResponseArticle
 */
export interface AdminUpdateArticle200ResponseArticle {
    /**
     * 
     * @type {number}
     * @memberof AdminUpdateArticle200ResponseArticle
     */
    'id'?: number;

    /**
     * 
     * @type {string}
     * @memberof AdminUpdateArticle200ResponseArticle
     */
    'title'?: string;

    /**
     * 
     * @type {string}
     * @memberof AdminUpdateArticle200ResponseArticle
     */
    'slug'?: string;

    /**
     * 
     * @type {string}
     * @memberof AdminUpdateArticle200ResponseArticle
     */
    'summary'?: string;

    /**
     * 
     * @type {string}
     * @memberof AdminUpdateArticle200ResponseArticle
     */
    'content'?: string;

    /**
     * 
     * @type {string}
     * @memberof AdminUpdateArticle200ResponseArticle
     */
    'markdownContent'?: string;

    /**
     * 
     * @type {string}
     * @memberof AdminUpdateArticle200ResponseArticle
     */
    'status'?: AdminUpdateArticleRequestStatusEnum;

    /**
     * 
     * @type {string}
     * @memberof AdminUpdateArticle200ResponseArticle
     */
    'authorId'?: string;

    /**
     * 
     * @type {number}
     * @memberof AdminUpdateArticle200ResponseArticle
     */
    'categoryId'?: number;

    /**
     * 
     * @type {string}
     * @memberof AdminUpdateArticle200ResponseArticle
     */
    'thumbnailUrl'?: string;

    /**
     * 
     * @type {number[]}
     * @memberof AdminUpdateArticle200ResponseArticle
     */
    'tagIds'?: number[];
}
/**
 * 
 * @export
 * @interface AdminUpdateArticle400Response
 */
export interface AdminUpdateArticle400Response {
    /**
     * 
     * @type {string}
     * @memberof AdminUpdateArticle400Response
     */
    'error'?: string;

    /**
     * 
     * @type {Array<AdminUpdateArticle400ResponseErrorsInner>}
     * @memberof AdminUpdateArticle400Response
     */
    'errors'?: Array<AdminUpdateArticle400ResponseErrorsInner>;
}
/**
 * 
 * @export
 * @interface AdminUpdateArticle400ResponseErrorsInner
 */
export interface AdminUpdateArticle400ResponseErrorsInner {
    /**
     * 
     * @type {string}
     * @memberof AdminUpdateArticle400ResponseErrorsInner
     */
    'path'?: string;

    /**
     * 
     * @type {string}
     * @memberof AdminUpdateArticle400ResponseErrorsInner
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface AdminUpdateArticle404Response
 */
export interface AdminUpdateArticle404Response {
    /**
     * 
     * @type {string}
     * @memberof AdminUpdateArticle404Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface AdminUpdateArticle500Response
 */
export interface AdminUpdateArticle500Response {
    /**
     * 
     * @type {string}
     * @memberof AdminUpdateArticle500Response
     */
    'error'?: string;

    /**
     * 
     * @type {string}
     * @memberof AdminUpdateArticle500Response
     */
    'message'?: string;
}

/**
 * 
 * @export
 * @interface ChangePassword400Response
 */
export interface ChangePassword400Response {
    /**
     * 
     * @type {string}
     * @memberof ChangePassword400Response
     */
    'error'?: string;
    /**
     * 
     * @type {Array<ChangePassword400ResponseDetailsInner>}
     * @memberof ChangePassword400Response
     */
    'details'?: Array<ChangePassword400ResponseDetailsInner>;
}
/**
 * 
 * @export
 * @interface ChangePassword400ResponseDetailsInner
 */
export interface ChangePassword400ResponseDetailsInner {
    /**
     * 
     * @type {Array<string>}
     * @memberof ChangePassword400ResponseDetailsInner
     */
    'path'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ChangePassword400ResponseDetailsInner
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ChangePassword401Response
 */
export interface ChangePassword401Response {
    /**
     * 
     * @type {string}
     * @memberof ChangePassword401Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface ChangePasswordRequest
 */
export interface ChangePasswordRequest {
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordRequest
     */
    'oldPassword': string;
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordRequest
     */
    'newPassword': string;
}
/**
 * 
 * @export
 * @interface Created
 */
export interface Created {
    /**
     * 
     * @type {string}
     * @memberof Created
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface CreatedWithId
 */
export interface CreatedWithId {
    /**
     * 
     * @type {string}
     * @memberof CreatedWithId
     */
    'message': string;
    /**
     * 
     * @type {number}
     * @memberof CreatedWithId
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface ForbiddenError
 */
export interface ForbiddenError {
    /**
     * 
     * @type {string}
     * @memberof ForbiddenError
     */
    'error'?: string;
    /**
     * 
     * @type {string}
     * @memberof ForbiddenError
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ForgetPassword400Response
 */
export interface ForgetPassword400Response {
    /**
     * 
     * @type {string}
     * @memberof ForgetPassword400Response
     */
    'error'?: string;
    /**
     * 
     * @type {Array<ChangePassword400ResponseDetailsInner>}
     * @memberof ForgetPassword400Response
     */
    'details'?: Array<ChangePassword400ResponseDetailsInner>;
}
/**
 * 
 * @export
 * @interface ForgetPassword404Response
 */
export interface ForgetPassword404Response {
    /**
     * 
     * @type {string}
     * @memberof ForgetPassword404Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface ForgetPassword429Response
 */
export interface ForgetPassword429Response {
    /**
     * 
     * @type {string}
     * @memberof ForgetPassword429Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface ForgetPasswordRequest
 */
export interface ForgetPasswordRequest {
    /**
     * 
     * @type {string}
     * @memberof ForgetPasswordRequest
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface GetArticles200Response
 */
export interface GetArticles200Response {
    /**
     * 
     * @type {string}
     * @memberof GetArticles200Response
     */
    'message'?: string;
    /**
     * The total number of articles matching the query.
     * @type {number}
     * @memberof GetArticles200Response
     */
    'total'?: number;
    /**
     * 
     * @type {Array<GetArticles200ResponseArticlesInner>}
     * @memberof GetArticles200Response
     */
    'articles'?: Array<GetArticles200ResponseArticlesInner>;
}
/**
 * 
 * @export
 * @interface GetArticles200ResponseArticlesInner
 */
export interface GetArticles200ResponseArticlesInner {
    /**
     * The unique identifier for the article.
     * @type {number}
     * @memberof GetArticles200ResponseArticlesInner
     */
    'id'?: number;
    /**
     * The title of the article.
     * @type {string}
     * @memberof GetArticles200ResponseArticlesInner
     */
    'title'?: string;
    /**
     * The unique slug for the article.
     * @type {string}
     * @memberof GetArticles200ResponseArticlesInner
     */
    'slug'?: string;
    /**
     * A brief summary of the article.
     * @type {string}
     * @memberof GetArticles200ResponseArticlesInner
     */
    'summary'?: string;
    /**
     * The URL of the article\'s thumbnail image (optional).
     * @type {string}
     * @memberof GetArticles200ResponseArticlesInner
     */
    'thumbnailUrl'?: string | null;
    /**
     * The publication status of the article.
     * @type {string}
     * @memberof GetArticles200ResponseArticlesInner
     */
    'status'?: GetArticles200ResponseArticlesInnerStatusEnum;
    /**
     * 
     * @type {GetArticles200ResponseArticlesInnerAuthor}
     * @memberof GetArticles200ResponseArticlesInner
     */
    'author'?: GetArticles200ResponseArticlesInnerAuthor;
    /**
     * 
     * @type {GetArticles200ResponseArticlesInnerCategory}
     * @memberof GetArticles200ResponseArticlesInner
     */
    'category'?: GetArticles200ResponseArticlesInnerCategory;
    /**
     * The date and time when the article was created.
     * @type {string}
     * @memberof GetArticles200ResponseArticlesInner
     */
    'createdAt'?: string;
    /**
     * The date and time when the article was last updated.
     * @type {string}
     * @memberof GetArticles200ResponseArticlesInner
     */
    'updatedAt'?: string;
    /**
     * The date and time when the article was deleted (optional).
     * @type {string}
     * @memberof GetArticles200ResponseArticlesInner
     */
    'deletedAt'?: string | null;
}

export const GetArticles200ResponseArticlesInnerStatusEnum = {
    Draft: 'DRAFT',
    Published: 'PUBLISHED',
    Archived: 'ARCHIVED'
} as const;

export type GetArticles200ResponseArticlesInnerStatusEnum = typeof GetArticles200ResponseArticlesInnerStatusEnum[keyof typeof GetArticles200ResponseArticlesInnerStatusEnum];

/**
 * The author of the article.
 * @export
 * @interface GetArticles200ResponseArticlesInnerAuthor
 */
export interface GetArticles200ResponseArticlesInnerAuthor {
    /**
     * The unique identifier for the author.
     * @type {string}
     * @memberof GetArticles200ResponseArticlesInnerAuthor
     */
    'id'?: string;
    /**
     * The name of the author (optional, assuming Author model has a name field).
     * @type {string}
     * @memberof GetArticles200ResponseArticlesInnerAuthor
     */
    'name'?: string;
}
/**
 * The category of the article.
 * @export
 * @interface GetArticles200ResponseArticlesInnerCategory
 */
export interface GetArticles200ResponseArticlesInnerCategory {
    /**
     * The unique identifier for the category.
     * @type {number}
     * @memberof GetArticles200ResponseArticlesInnerCategory
     */
    'id'?: number;
    /**
     * The name of the category.
     * @type {string}
     * @memberof GetArticles200ResponseArticlesInnerCategory
     */
    'name'?: string;
    /**
     * The unique slug for the category.
     * @type {string}
     * @memberof GetArticles200ResponseArticlesInnerCategory
     */
    'slug'?: string;
}
/**
 * 
 * @export
 * @interface GetCategories200Response
 */
export interface GetCategories200Response {
    /**
     * 
     * @type {string}
     * @memberof GetCategories200Response
     */
    'message'?: string;
    /**
     * 
     * @type {Array<AdminGetCategories200ResponseDataInner>}
     * @memberof GetCategories200Response
     */
    'categories'?: Array<AdminGetCategories200ResponseDataInner>;
}
/**
 * 
 * @export
 * @interface InternalServerError
 */
export interface InternalServerError {
    /**
     * 
     * @type {string}
     * @memberof InternalServerError
     */
    'error'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalServerError
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface NotFoundError
 */
export interface NotFoundError {
    /**
     * 
     * @type {string}
     * @memberof NotFoundError
     */
    'error'?: string;
    /**
     * 
     * @type {string}
     * @memberof NotFoundError
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface RegisterRequest
 */
export interface RegisterRequest {
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'gender': RegisterRequestGenderEnum;
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'confirmPassword': string;
}

export const RegisterRequestGenderEnum = {
    Male: 'male',
    Female: 'female',
    Other: 'other'
} as const;

export type RegisterRequestGenderEnum = typeof RegisterRequestGenderEnum[keyof typeof RegisterRequestGenderEnum];

/**
 * 
 * @export
 * @interface ResetPassword400Response
 */
export interface ResetPassword400Response {
    /**
     * 
     * @type {string}
     * @memberof ResetPassword400Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface ResetPasswordRequest
 */
export interface ResetPasswordRequest {
    /**
     * 
     * @type {string}
     * @memberof ResetPasswordRequest
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof ResetPasswordRequest
     */
    'newPassword': string;
}
/**
 * 
 * @export
 * @interface SubmitContactFormRequest
 */
export interface SubmitContactFormRequest {
    /**
     * The name of the company submitting the contact form.
     * @type {string}
     * @memberof SubmitContactFormRequest
     */
    'companyName': string;
    /**
     * The name of the contact person submitting the form.
     * @type {string}
     * @memberof SubmitContactFormRequest
     */
    'contactName': string;
    /**
     * The email address of the contact person.
     * @type {string}
     * @memberof SubmitContactFormRequest
     */
    'email': string;
    /**
     * The phone number of the contact person.
     * @type {string}
     * @memberof SubmitContactFormRequest
     */
    'phone': string;
    /**
     * The content of the inquiry or message.
     * @type {string}
     * @memberof SubmitContactFormRequest
     */
    'inquiry': string;
    /**
     * Indicates whether the user agrees to the privacy policy.
     * @type {boolean}
     * @memberof SubmitContactFormRequest
     */
    'privacyPolicy': boolean;
}
/**
 * 
 * @export
 * @interface Success
 */
export interface Success {
    /**
     * 
     * @type {string}
     * @memberof Success
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface UnAuthorizedError
 */
export interface UnAuthorizedError {
    /**
     * 
     * @type {string}
     * @memberof UnAuthorizedError
     */
    'error'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnAuthorizedError
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface UnprocessableEntity
 */
export interface UnprocessableEntity {
    /**
     * 
     * @type {string}
     * @memberof UnprocessableEntity
     */
    'error'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnprocessableEntity
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'error'?: string;
    /**
     * 
     * @type {Array<ValidationErrorErrorsInner>}
     * @memberof ValidationError
     */
    'errors'?: Array<ValidationErrorErrorsInner>;
}
/**
 * 
 * @export
 * @interface ValidationErrorErrorsInner
 */
export interface ValidationErrorErrorsInner {
    /**
     * 
     * @type {string}
     * @memberof ValidationErrorErrorsInner
     */
    'path'?: string;
    /**
     * 
     * @type {string}
     * @memberof ValidationErrorErrorsInner
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface VerifyEmail400Response
 */
export interface VerifyEmail400Response {
    /**
     * 
     * @type {string}
     * @memberof VerifyEmail400Response
     */
    'error'?: string;
    /**
     * 
     * @type {string}
     * @memberof VerifyEmail400Response
     */
    'message'?: string;
}

/**
 * AdminApi - axios parameter creator
 * @export
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new category with a unique name and slug.
         * @summary Create a new category
         * @param {AdminCreateCategoryRequest} adminCreateCategoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCreateCategory: async (adminCreateCategoryRequest: AdminCreateCategoryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminCreateCategoryRequest' is not null or undefined
            assertParamExists('adminCreateCategory', 'adminCreateCategoryRequest', adminCreateCategoryRequest)
            const localVarPath = `/api/admin/categories/create-category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminCreateCategoryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new tag with a unique name.
         * @summary Create a new tag
         * @param {AdminCreateTagRequest} adminCreateTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCreateTag: async (adminCreateTagRequest: AdminCreateTagRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminCreateTagRequest' is not null or undefined
            assertParamExists('adminCreateTag', 'adminCreateTagRequest', adminCreateTagRequest)
            const localVarPath = `/api/admin/tags/create-tag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminCreateTagRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new user, hashes their password, generates an email verification token, and sends a verification email.
         * @summary Register a new user
         * @param {AdminCreateUserRequest} adminCreateUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCreateUser: async (adminCreateUserRequest: AdminCreateUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminCreateUserRequest' is not null or undefined
            assertParamExists('adminCreateUser', 'adminCreateUserRequest', adminCreateUserRequest)
            const localVarPath = `/api/admin/users/create-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminCreateUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new article with content, slug, category, tags, and other metadata.
         * @summary Create a new article
         * @param {AdminCreateArticleRequest} adminCreateArticleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCreateArticle: async (adminCreateArticleRequest: AdminCreateArticleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminCreateArticleRequest' is not null or undefined
            assertParamExists('adminCreateArticle', 'adminCreateArticleRequest', adminCreateArticleRequest)
            const localVarPath = `/api/admin/articles/create-article`; // <- your route
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(adminCreateArticleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes categories by their IDs (soft delete, sets deletedAt).
         * @summary Delete categories by IDs
         * @param {AdminDeleteCategoriesRequest} adminDeleteCategoriesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteCategories: async (adminDeleteCategoriesRequest: AdminDeleteCategoriesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminDeleteCategoriesRequest' is not null or undefined
            assertParamExists('adminDeleteCategories', 'adminDeleteCategoriesRequest', adminDeleteCategoriesRequest)
            const localVarPath = `/api/admin/categories/delete-category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminDeleteCategoriesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes tags by their IDs (soft delete, sets deletedAt).
         * @summary Delete tags by IDs
         * @param {AdminDeleteCategoriesRequest} adminDeleteCategoriesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteTags: async (adminDeleteCategoriesRequest: AdminDeleteCategoriesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminDeleteCategoriesRequest' is not null or undefined
            assertParamExists('adminDeleteTags', 'adminDeleteCategoriesRequest', adminDeleteCategoriesRequest)
            const localVarPath = `/api/admin/tags/delete-tag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminDeleteCategoriesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Admin can delete user accounts including their own, but not other admins.
         * @summary Delete users by IDs
         * @param {AdminDeleteUsersRequest} adminDeleteUsersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteUsers: async (adminDeleteUsersRequest: AdminDeleteUsersRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminDeleteUsersRequest' is not null or undefined
            assertParamExists('adminDeleteUsers', 'adminDeleteUsersRequest', adminDeleteUsersRequest)
            const localVarPath = `/api/admin/users/delete-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminDeleteUsersRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        adminDeleteArticles: async (adminDeleteArticlesRequest: AdminDeleteArticlesRequest,options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExists('adminDeleteArticles', 'adminDeleteArticlesRequest', adminDeleteArticlesRequest);

            const localVarPath = `/api/admin/articles/delete-article`;
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions?.headers ?? {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(adminDeleteArticlesRequest, localVarRequestOptions, configuration);

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves categories from the database with pagination and optional search using query parameters.
         * @summary Fetch categories with pagination and search
         * @param {number} page The page number for pagination.
         * @param {number} limit The number of categories to return per page.
         * @param {string} [search] Optional search term to filter categories by name or description.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminGetCategories: async (page: number, limit: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'page' is not null or undefined
            assertParamExists('adminGetCategories', 'page', page)
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('adminGetCategories', 'limit', limit)
            const localVarPath = `/api/admin/categories/get-category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves tags from the database with pagination and optional search using query parameters.
         * @summary Fetch tags with pagination and search
         * @param {number} page The page number for pagination.
         * @param {number} limit The number of tags to return per page.
         * @param {string} [search] Optional search term to filter tags by name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminGetTags: async (page: number, limit: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'page' is not null or undefined
            assertParamExists('adminGetTags', 'page', page)
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('adminGetTags', 'limit', limit)
            const localVarPath = `/api/admin/tags/get-tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves users from the database with pagination and optional search.
         * @summary Fetch users with pagination and search
         * @param {AdminGetUsersRequest} adminGetUsersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminGetUsers: async (adminGetUsersRequest: AdminGetUsersRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminGetUsersRequest' is not null or undefined
            assertParamExists('adminGetUsers', 'adminGetUsersRequest', adminGetUsersRequest)
            const localVarPath = `/api/admin/users/get-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminGetUsersRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves articles from the database with pagination and optional search.
         * @summary Fetch articles with pagination and search
         * @param {AdminGetArticlesRequest} adminGetArticlesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminGetArticles: async (adminGetArticlesRequest: AdminGetArticlesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminGetArticlesRequest' is not null or undefined
            assertParamExists('adminGetArticles', 'adminGetArticlesRequest', adminGetArticlesRequest)
            const localVarPath = `/api/admin/articles/get-article`; // <-- adjust route if needed
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(adminGetArticlesRequest, localVarRequestOptions, configuration);

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates details of an existing category based on the provided category ID.
         * @summary Update category details
         * @param {AdminUpdateCategoryRequest} adminUpdateCategoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpdateCategory: async (adminUpdateCategoryRequest: AdminUpdateCategoryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminUpdateCategoryRequest' is not null or undefined
            assertParamExists('adminUpdateCategory', 'adminUpdateCategoryRequest', adminUpdateCategoryRequest)
            const localVarPath = `/api/admin/categories/update-category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminUpdateCategoryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves authors from the database with pagination and optional search.
         * @summary Fetch authors with pagination and search
         * @param {AdminGetAuthorsRequest} adminGetAuthorsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminGetAuthors: async (
            adminGetAuthorsRequest: AdminGetAuthorsRequest,
            options: RawAxiosRequestConfig = {}
        ): Promise<RequestArgs> => {
            // verify required parameter 'adminGetAuthorsRequest' is not null or undefined
            assertParamExists('adminGetAuthors', 'adminGetAuthorsRequest', adminGetAuthorsRequest);

            const localVarPath = `/api/admin/authors/get-author`;
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);

            const headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            localVarRequestOptions.data = serializeDataIfNeeded(
                adminGetAuthorsRequest,
                localVarRequestOptions,
                configuration
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates details of an existing tag based on the provided tag ID.
         * @summary Update tag details
         * @param {AdminUpdateTagRequest} adminUpdateTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpdateTag: async (adminUpdateTagRequest: AdminUpdateTagRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminUpdateTagRequest' is not null or undefined
            assertParamExists('adminUpdateTag', 'adminUpdateTagRequest', adminUpdateTagRequest)
            const localVarPath = `/api/admin/tags/update-tag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminUpdateTagRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update details of an existing user based on the provided user ID.
         * @summary Update user details
         * @param {AdminUpdateUserRequest} adminUpdateUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpdateUser: async (adminUpdateUserRequest: AdminUpdateUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminUpdateUserRequest' is not null or undefined
            assertParamExists('adminUpdateUser', 'adminUpdateUserRequest', adminUpdateUserRequest)
            const localVarPath = `/api/admin/users/update-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminUpdateUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update details of an existing article based on the provided article ID.
         * @summary Update article details
         * @param {AdminUpdateArticleRequest} adminUpdateArticleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpdateArticle: async (adminUpdateArticleRequest: AdminUpdateArticleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminUpdateArticleRequest' is not null or undefined
            assertParamExists('adminUpdateArticle', 'adminUpdateArticleRequest', adminUpdateArticleRequest);

            const localVarPath = `/api/admin/articles/update-article`; //  adjust to your actual backend route
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);

            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);

            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            localVarRequestOptions.data = serializeDataIfNeeded(
                adminUpdateArticleRequest,
                localVarRequestOptions,
                configuration
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },

    }
};

/**
 * AdminApi - functional programming interface
 * @export
 */
export const AdminApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new category with a unique name and slug.
         * @summary Create a new category
         * @param {AdminCreateCategoryRequest} adminCreateCategoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminCreateCategory(adminCreateCategoryRequest: AdminCreateCategoryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminCreateCategory201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminCreateCategory(adminCreateCategoryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminCreateCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new tag with a unique name.
         * @summary Create a new tag
         * @param {AdminCreateTagRequest} adminCreateTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminCreateTag(adminCreateTagRequest: AdminCreateTagRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminCreateTag201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminCreateTag(adminCreateTagRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminCreateTag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new user, hashes their password, generates an email verification token, and sends a verification email.
         * @summary Register a new user
         * @param {AdminCreateUserRequest} adminCreateUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminCreateUser(adminCreateUserRequest: AdminCreateUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Created>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminCreateUser(adminCreateUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminCreateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        async adminCreateArticle(adminCreateArticleRequest: AdminCreateArticleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Created>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminCreateArticle(adminCreateArticleRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminCreateArticle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes categories by their IDs (soft delete, sets deletedAt).
         * @summary Delete categories by IDs
         * @param {AdminDeleteCategoriesRequest} adminDeleteCategoriesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminDeleteCategories(adminDeleteCategoriesRequest: AdminDeleteCategoriesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminDeleteCategories(adminDeleteCategoriesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminDeleteCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes tags by their IDs (soft delete, sets deletedAt).
         * @summary Delete tags by IDs
         * @param {AdminDeleteCategoriesRequest} adminDeleteCategoriesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminDeleteTags(adminDeleteCategoriesRequest: AdminDeleteCategoriesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminDeleteTags(adminDeleteCategoriesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminDeleteTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Admin can delete user accounts including their own, but not other admins.
         * @summary Delete users by IDs
         * @param {AdminDeleteUsersRequest} adminDeleteUsersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminDeleteUsers(adminDeleteUsersRequest: AdminDeleteUsersRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminDeleteUsers(adminDeleteUsersRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminDeleteUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Admin can delete articles by their IDs (soft delete, sets deletedAt).
         * @summary Delete articles by IDs
         * @param {AdminDeleteArticlesRequest} adminDeleteArticlesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminDeleteArticles(adminDeleteArticlesRequest: AdminDeleteArticlesRequest,options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminDeleteArticles(adminDeleteArticlesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminDeleteArticles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios,localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves categories from the database with pagination and optional search using query parameters.
         * @summary Fetch categories with pagination and search
         * @param {number} page The page number for pagination.
         * @param {number} limit The number of categories to return per page.
         * @param {string} [search] Optional search term to filter categories by name or description.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminGetCategories(page: number, limit: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminGetCategories200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminGetCategories(page, limit, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminGetCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves tags from the database with pagination and optional search using query parameters.
         * @summary Fetch tags with pagination and search
         * @param {number} page The page number for pagination.
         * @param {number} limit The number of tags to return per page.
         * @param {string} [search] Optional search term to filter tags by name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminGetTags(page: number, limit: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminGetTags200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminGetTags(page, limit, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminGetTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves users from the database with pagination and optional search.
         * @summary Fetch users with pagination and search
         * @param {AdminGetUsersRequest} adminGetUsersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminGetUsers(adminGetUsersRequest: AdminGetUsersRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminGetUsers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminGetUsers(adminGetUsersRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminGetUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves articles from the database with pagination and optional search.
         * @summary Fetch articles with pagination and search
         * @param {AdminGetArticlesRequest} adminGetArticlesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminGetArticles(adminGetArticlesRequest: AdminGetArticlesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminGetArticles200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminGetArticles(adminGetArticlesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminGetArticles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates details of an existing category based on the provided category ID.
         * @summary Update category details
         * @param {AdminUpdateCategoryRequest} adminUpdateCategoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUpdateCategory(adminUpdateCategoryRequest: AdminUpdateCategoryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminUpdateCategory200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUpdateCategory(adminUpdateCategoryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminUpdateCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates details of an existing tag based on the provided tag ID.
         * @summary Update tag details
         * @param {AdminUpdateTagRequest} adminUpdateTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUpdateTag(adminUpdateTagRequest: AdminUpdateTagRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminUpdateTag200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUpdateTag(adminUpdateTagRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminUpdateTag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update details of an existing user based on the provided user ID.
         * @summary Update user details
         * @param {AdminUpdateUserRequest} adminUpdateUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUpdateUser(adminUpdateUserRequest: AdminUpdateUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminUpdateUser200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUpdateUser(adminUpdateUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminUpdateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update details of an existing article based on the provided article ID.
         * @summary Update article details
         * @param {AdminUpdateArticleRequest} adminUpdateArticleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUpdateArticle(
        adminUpdateArticleRequest: AdminUpdateArticleRequest,
        options?: RawAxiosRequestConfig
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminUpdateArticle200Response>> {
        const localVarAxiosArgs = await localVarAxiosParamCreator.adminUpdateArticle(adminUpdateArticleRequest, options);
        const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
        const localVarOperationServerBasePath = operationServerMap['AdminApi.adminUpdateArticle']?.[localVarOperationServerIndex]?.url;

        return (axios, basePath) =>
            createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves authors from the database with pagination and optional search.
         * @summary Fetch authors with pagination and search
         * @param {AdminGetAuthorsRequest} adminGetAuthorsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminGetAuthors(
            adminGetAuthorsRequest: AdminGetAuthorsRequest,
            options?: RawAxiosRequestConfig
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminGetAuthors200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminGetAuthors(adminGetAuthorsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['AdminApi.adminGetAuthors']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(
                axios,
                localVarOperationServerBasePath || basePath
                );
        },
    }
};

/**
 * AdminApi - factory interface
 * @export
 */
export const AdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminApiFp(configuration)
    return {
        /**
         * Creates a new category with a unique name and slug.
         * @summary Create a new category
         * @param {AdminCreateCategoryRequest} adminCreateCategoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCreateCategory(adminCreateCategoryRequest: AdminCreateCategoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<AdminCreateCategory201Response> {
            return localVarFp.adminCreateCategory(adminCreateCategoryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new tag with a unique name.
         * @summary Create a new tag
         * @param {AdminCreateTagRequest} adminCreateTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCreateTag(adminCreateTagRequest: AdminCreateTagRequest, options?: RawAxiosRequestConfig): AxiosPromise<AdminCreateTag201Response> {
            return localVarFp.adminCreateTag(adminCreateTagRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new user, hashes their password, generates an email verification token, and sends a verification email.
         * @summary Register a new user
         * @param {AdminCreateUserRequest} adminCreateUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCreateUser(adminCreateUserRequest: AdminCreateUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<Created> {
            return localVarFp.adminCreateUser(adminCreateUserRequest, options).then((request) => request(axios, basePath));
        },
        /** */
        adminCreateArticle(adminCreateArticleRequest: AdminCreateArticleRequest, options?: RawAxiosRequestConfig): AxiosPromise<Created> {
            return localVarFp.adminCreateArticle(adminCreateArticleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes categories by their IDs (soft delete, sets deletedAt).
         * @summary Delete categories by IDs
         * @param {AdminDeleteCategoriesRequest} adminDeleteCategoriesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteCategories(adminDeleteCategoriesRequest: AdminDeleteCategoriesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Success> {
            return localVarFp.adminDeleteCategories(adminDeleteCategoriesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes tags by their IDs (soft delete, sets deletedAt).
         * @summary Delete tags by IDs
         * @param {AdminDeleteCategoriesRequest} adminDeleteCategoriesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteTags(adminDeleteCategoriesRequest: AdminDeleteCategoriesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Success> {
            return localVarFp.adminDeleteTags(adminDeleteCategoriesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Admin can delete user accounts including their own, but not other admins.
         * @summary Delete users by IDs
         * @param {AdminDeleteUsersRequest} adminDeleteUsersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteUsers(adminDeleteUsersRequest: AdminDeleteUsersRequest, options?: RawAxiosRequestConfig): AxiosPromise<Success> {
            return localVarFp.adminDeleteUsers(adminDeleteUsersRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Admin can delete articles by their IDs (soft delete, sets deletedAt).
         * @summary Delete articles by IDs
         * @param {AdminDeleteArticlesRequest} adminDeleteArticlesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteArticles(adminDeleteArticlesRequest: AdminDeleteArticlesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Success> {
            return localVarFp.adminDeleteArticles(adminDeleteArticlesRequest, options).then((request) => request(axios, basePath));
        },

        /**
         * Retrieves categories from the database with pagination and optional search using query parameters.
         * @summary Fetch categories with pagination and search
         * @param {number} page The page number for pagination.
         * @param {number} limit The number of categories to return per page.
         * @param {string} [search] Optional search term to filter categories by name or description.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminGetCategories(page: number, limit: number, search?: string, options?: RawAxiosRequestConfig): AxiosPromise<AdminGetCategories200Response> {
            return localVarFp.adminGetCategories(page, limit, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves tags from the database with pagination and optional search using query parameters.
         * @summary Fetch tags with pagination and search
         * @param {number} page The page number for pagination.
         * @param {number} limit The number of tags to return per page.
         * @param {string} [search] Optional search term to filter tags by name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminGetTags(page: number, limit: number, search?: string, options?: RawAxiosRequestConfig): AxiosPromise<AdminGetTags200Response> {
            return localVarFp.adminGetTags(page, limit, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves users from the database with pagination and optional search.
         * @summary Fetch users with pagination and search
         * @param {AdminGetUsersRequest} adminGetUsersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminGetUsers(adminGetUsersRequest: AdminGetUsersRequest, options?: RawAxiosRequestConfig): AxiosPromise<AdminGetUsers200Response> {
            return localVarFp.adminGetUsers(adminGetUsersRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves articles from the database with pagination and optional search.
         * @summary Fetch articles with pagination and search
         * @param {AdminGetArticlesRequest} adminGetArticlesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminGetArticles(adminGetArticlesRequest: AdminGetArticlesRequest, options?: RawAxiosRequestConfig): AxiosPromise<AdminGetArticles200Response> {
            return localVarFp.adminGetArticles(adminGetArticlesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates details of an existing category based on the provided category ID.
         * @summary Update category details
         * @param {AdminUpdateCategoryRequest} adminUpdateCategoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpdateCategory(adminUpdateCategoryRequest: AdminUpdateCategoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<AdminUpdateCategory200Response> {
            return localVarFp.adminUpdateCategory(adminUpdateCategoryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates details of an existing tag based on the provided tag ID.
         * @summary Update tag details
         * @param {AdminUpdateTagRequest} adminUpdateTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpdateTag(adminUpdateTagRequest: AdminUpdateTagRequest, options?: RawAxiosRequestConfig): AxiosPromise<AdminUpdateTag200Response> {
            return localVarFp.adminUpdateTag(adminUpdateTagRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update details of an existing user based on the provided user ID.
         * @summary Update user details
         * @param {AdminUpdateUserRequest} adminUpdateUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpdateUser(adminUpdateUserRequest: AdminUpdateUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<AdminUpdateUser200Response> {
            return localVarFp.adminUpdateUser(adminUpdateUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update details of an existing article based on the provided user ID.
         * @summary Update article details
         * @param {AdminUpdateArticleRequest} adminUpdateUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpdateArticle(adminUpdateArticleRequest: AdminUpdateArticleRequest, options?: RawAxiosRequestConfig): AxiosPromise<AdminUpdateArticle200Response> {
            return localVarFp.adminUpdateArticle(adminUpdateArticleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves authors from the database with pagination and optional search.
         * @summary Fetch authors with pagination and search
         * @param {AdminGetAuthorsRequest} adminGetAuthorsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminGetAuthors(adminGetAuthorsRequest: AdminGetAuthorsRequest, options?: RawAxiosRequestConfig): AxiosPromise<AdminGetAuthors200Response> {
            return localVarFp.adminGetAuthors(adminGetAuthorsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */
export class AdminApi extends BaseAPI {
    /**
     * Creates a new category with a unique name and slug.
     * @summary Create a new category
     * @param {AdminCreateCategoryRequest} adminCreateCategoryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminCreateCategory(adminCreateCategoryRequest: AdminCreateCategoryRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminCreateCategory(adminCreateCategoryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new tag with a unique name.
     * @summary Create a new tag
     * @param {AdminCreateTagRequest} adminCreateTagRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminCreateTag(adminCreateTagRequest: AdminCreateTagRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminCreateTag(adminCreateTagRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new user, hashes their password, generates an email verification token, and sends a verification email.
     * @summary Register a new user
     * @param {AdminCreateUserRequest} adminCreateUserRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminCreateUser(adminCreateUserRequest: AdminCreateUserRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminCreateUser(adminCreateUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes categories by their IDs (soft delete, sets deletedAt).
     * @summary Delete categories by IDs
     * @param {AdminDeleteCategoriesRequest} adminDeleteCategoriesRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminDeleteCategories(adminDeleteCategoriesRequest: AdminDeleteCategoriesRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminDeleteCategories(adminDeleteCategoriesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes tags by their IDs (soft delete, sets deletedAt).
     * @summary Delete tags by IDs
     * @param {AdminDeleteCategoriesRequest} adminDeleteCategoriesRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminDeleteTags(adminDeleteCategoriesRequest: AdminDeleteCategoriesRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminDeleteTags(adminDeleteCategoriesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Admin can delete user accounts including their own, but not other admins.
     * @summary Delete users by IDs
     * @param {AdminDeleteUsersRequest} adminDeleteUsersRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminDeleteUsers(adminDeleteUsersRequest: AdminDeleteUsersRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminDeleteUsers(adminDeleteUsersRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves categories from the database with pagination and optional search using query parameters.
     * @summary Fetch categories with pagination and search
     * @param {number} page The page number for pagination.
     * @param {number} limit The number of categories to return per page.
     * @param {string} [search] Optional search term to filter categories by name or description.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminGetCategories(page: number, limit: number, search?: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminGetCategories(page, limit, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves tags from the database with pagination and optional search using query parameters.
     * @summary Fetch tags with pagination and search
     * @param {number} page The page number for pagination.
     * @param {number} limit The number of tags to return per page.
     * @param {string} [search] Optional search term to filter tags by name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminGetTags(page: number, limit: number, search?: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminGetTags(page, limit, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves users from the database with pagination and optional search.
     * @summary Fetch users with pagination and search
     * @param {AdminGetUsersRequest} adminGetUsersRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminGetUsers(adminGetUsersRequest: AdminGetUsersRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminGetUsers(adminGetUsersRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates details of an existing category based on the provided category ID.
     * @summary Update category details
     * @param {AdminUpdateCategoryRequest} adminUpdateCategoryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminUpdateCategory(adminUpdateCategoryRequest: AdminUpdateCategoryRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminUpdateCategory(adminUpdateCategoryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates details of an existing tag based on the provided tag ID.
     * @summary Update tag details
     * @param {AdminUpdateTagRequest} adminUpdateTagRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminUpdateTag(adminUpdateTagRequest: AdminUpdateTagRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminUpdateTag(adminUpdateTagRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update details of an existing user based on the provided user ID.
     * @summary Update user details
     * @param {AdminUpdateUserRequest} adminUpdateUserRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminUpdateUser(adminUpdateUserRequest: AdminUpdateUserRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminUpdateUser(adminUpdateUserRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ArticlesApi - axios parameter creator
 * @export
 */
export const ArticlesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves articles from the database with pagination using skip and take query parameters, optionally filtered by category.
         * @summary Fetch articles with pagination
         * @param {number} skip The number of articles to skip for pagination.
         * @param {number} take The number of articles to return per request.
         * @param {string} [category] The name of the category to filter articles by (optional).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArticles: async (skip: number, take: number, category?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'skip' is not null or undefined
            assertParamExists('getArticles', 'skip', skip)
            // verify required parameter 'take' is not null or undefined
            assertParamExists('getArticles', 'take', take)
            const localVarPath = `/api/articles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArticlesApi - functional programming interface
 * @export
 */
export const ArticlesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ArticlesApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves articles from the database with pagination using skip and take query parameters, optionally filtered by category.
         * @summary Fetch articles with pagination
         * @param {number} skip The number of articles to skip for pagination.
         * @param {number} take The number of articles to return per request.
         * @param {string} [category] The name of the category to filter articles by (optional).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArticles(skip: number, take: number, category?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetArticles200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArticles(skip, take, category, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ArticlesApi.getArticles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ArticlesApi - factory interface
 * @export
 */
export const ArticlesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ArticlesApiFp(configuration)
    return {
        /**
         * Retrieves articles from the database with pagination using skip and take query parameters, optionally filtered by category.
         * @summary Fetch articles with pagination
         * @param {number} skip The number of articles to skip for pagination.
         * @param {number} take The number of articles to return per request.
         * @param {string} [category] The name of the category to filter articles by (optional).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArticles(skip: number, take: number, category?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetArticles200Response> {
            return localVarFp.getArticles(skip, take, category, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ArticlesApi - object-oriented interface
 * @export
 * @class ArticlesApi
 * @extends {BaseAPI}
 */
export class ArticlesApi extends BaseAPI {
    /**
     * Retrieves articles from the database with pagination using skip and take query parameters, optionally filtered by category.
     * @summary Fetch articles with pagination
     * @param {number} skip The number of articles to skip for pagination.
     * @param {number} take The number of articles to return per request.
     * @param {string} [category] The name of the category to filter articles by (optional).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArticlesApi
     */
    public getArticles(skip: number, take: number, category?: string, options?: RawAxiosRequestConfig) {
        return ArticlesApiFp(this.configuration).getArticles(skip, take, category, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Allows an authenticated user to change their password by providing the old and new password.
         * @summary Change user password
         * @param {ChangePasswordRequest} changePasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword: async (changePasswordRequest: ChangePasswordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'changePasswordRequest' is not null or undefined
            assertParamExists('changePassword', 'changePasswordRequest', changePasswordRequest)
            const localVarPath = `/api/auth/change-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changePasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends a reset password email with a secure token link. Each user is allowed a maximum of 3 emails per hour.
         * @summary Send a password reset email
         * @param {ForgetPasswordRequest} forgetPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgetPassword: async (forgetPasswordRequest: ForgetPasswordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'forgetPasswordRequest' is not null or undefined
            assertParamExists('forgetPassword', 'forgetPasswordRequest', forgetPasswordRequest)
            const localVarPath = `/api/auth/forget-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(forgetPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new user, hashes their password, generates an email verification token, and sends a verification email.
         * @summary Register a new user
         * @param {RegisterRequest} registerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register: async (registerRequest: RegisterRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerRequest' is not null or undefined
            assertParamExists('register', 'registerRequest', registerRequest)
            const localVarPath = `/api/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resets the user\'s password using a provided reset token and new password. The reset token is invalidated after the reset.
         * @summary Reset password for a user
         * @param {ResetPasswordRequest} resetPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword: async (resetPasswordRequest: ResetPasswordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resetPasswordRequest' is not null or undefined
            assertParamExists('resetPassword', 'resetPasswordRequest', resetPasswordRequest)
            const localVarPath = `/api/reset-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint sends a verification email to the user with the provided email address.
         * @summary Send verification email to a registered user
         * @param {ForgetPasswordRequest} forgetPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendVerificationEmail: async (forgetPasswordRequest: ForgetPasswordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'forgetPasswordRequest' is not null or undefined
            assertParamExists('sendVerificationEmail', 'forgetPasswordRequest', forgetPasswordRequest)
            const localVarPath = `/api/auth/verify-email-request`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(forgetPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verifies the user\'s email address using a provided verification token. Marks the user\'s email as verified in the database.
         * @summary Verify user email
         * @param {string} token The email verification token sent to the user\&#39;s email address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmail: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('verifyEmail', 'token', token)
            const localVarPath = `/api/auth/verify-email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Allows an authenticated user to change their password by providing the old and new password.
         * @summary Change user password
         * @param {ChangePasswordRequest} changePasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changePassword(changePasswordRequest: ChangePasswordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changePassword(changePasswordRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.changePassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sends a reset password email with a secure token link. Each user is allowed a maximum of 3 emails per hour.
         * @summary Send a password reset email
         * @param {ForgetPasswordRequest} forgetPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forgetPassword(forgetPasswordRequest: ForgetPasswordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forgetPassword(forgetPasswordRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.forgetPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new user, hashes their password, generates an email verification token, and sends a verification email.
         * @summary Register a new user
         * @param {RegisterRequest} registerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async register(registerRequest: RegisterRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Created>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.register(registerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.register']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resets the user\'s password using a provided reset token and new password. The reset token is invalidated after the reset.
         * @summary Reset password for a user
         * @param {ResetPasswordRequest} resetPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetPassword(resetPasswordRequest: ResetPasswordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetPassword(resetPasswordRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.resetPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint sends a verification email to the user with the provided email address.
         * @summary Send verification email to a registered user
         * @param {ForgetPasswordRequest} forgetPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendVerificationEmail(forgetPasswordRequest: ForgetPasswordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendVerificationEmail(forgetPasswordRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.sendVerificationEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Verifies the user\'s email address using a provided verification token. Marks the user\'s email as verified in the database.
         * @summary Verify user email
         * @param {string} token The email verification token sent to the user\&#39;s email address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyEmail(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyEmail(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.verifyEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Allows an authenticated user to change their password by providing the old and new password.
         * @summary Change user password
         * @param {ChangePasswordRequest} changePasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(changePasswordRequest: ChangePasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<Success> {
            return localVarFp.changePassword(changePasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends a reset password email with a secure token link. Each user is allowed a maximum of 3 emails per hour.
         * @summary Send a password reset email
         * @param {ForgetPasswordRequest} forgetPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgetPassword(forgetPasswordRequest: ForgetPasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<Success> {
            return localVarFp.forgetPassword(forgetPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new user, hashes their password, generates an email verification token, and sends a verification email.
         * @summary Register a new user
         * @param {RegisterRequest} registerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(registerRequest: RegisterRequest, options?: RawAxiosRequestConfig): AxiosPromise<Created> {
            return localVarFp.register(registerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Resets the user\'s password using a provided reset token and new password. The reset token is invalidated after the reset.
         * @summary Reset password for a user
         * @param {ResetPasswordRequest} resetPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword(resetPasswordRequest: ResetPasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<Success> {
            return localVarFp.resetPassword(resetPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint sends a verification email to the user with the provided email address.
         * @summary Send verification email to a registered user
         * @param {ForgetPasswordRequest} forgetPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendVerificationEmail(forgetPasswordRequest: ForgetPasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<Success> {
            return localVarFp.sendVerificationEmail(forgetPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Verifies the user\'s email address using a provided verification token. Marks the user\'s email as verified in the database.
         * @summary Verify user email
         * @param {string} token The email verification token sent to the user\&#39;s email address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmail(token: string, options?: RawAxiosRequestConfig): AxiosPromise<Success> {
            return localVarFp.verifyEmail(token, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Allows an authenticated user to change their password by providing the old and new password.
     * @summary Change user password
     * @param {ChangePasswordRequest} changePasswordRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public changePassword(changePasswordRequest: ChangePasswordRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).changePassword(changePasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sends a reset password email with a secure token link. Each user is allowed a maximum of 3 emails per hour.
     * @summary Send a password reset email
     * @param {ForgetPasswordRequest} forgetPasswordRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public forgetPassword(forgetPasswordRequest: ForgetPasswordRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).forgetPassword(forgetPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new user, hashes their password, generates an email verification token, and sends a verification email.
     * @summary Register a new user
     * @param {RegisterRequest} registerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public register(registerRequest: RegisterRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).register(registerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resets the user\'s password using a provided reset token and new password. The reset token is invalidated after the reset.
     * @summary Reset password for a user
     * @param {ResetPasswordRequest} resetPasswordRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public resetPassword(resetPasswordRequest: ResetPasswordRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).resetPassword(resetPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint sends a verification email to the user with the provided email address.
     * @summary Send verification email to a registered user
     * @param {ForgetPasswordRequest} forgetPasswordRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public sendVerificationEmail(forgetPasswordRequest: ForgetPasswordRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).sendVerificationEmail(forgetPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verifies the user\'s email address using a provided verification token. Marks the user\'s email as verified in the database.
     * @summary Verify user email
     * @param {string} token The email verification token sent to the user\&#39;s email address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public verifyEmail(token: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).verifyEmail(token, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CategoriesApi - axios parameter creator
 * @export
 */
export const CategoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves categories from the database with pagination using skip and take query parameters.
         * @summary Fetch categories with pagination
         * @param {number} skip The number of categories to skip for pagination.
         * @param {number} take The number of categories to return per request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategories: async (skip: number, take: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'skip' is not null or undefined
            assertParamExists('getCategories', 'skip', skip)
            // verify required parameter 'take' is not null or undefined
            assertParamExists('getCategories', 'take', take)
            const localVarPath = `/api/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoriesApi - functional programming interface
 * @export
 */
export const CategoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CategoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves categories from the database with pagination using skip and take query parameters.
         * @summary Fetch categories with pagination
         * @param {number} skip The number of categories to skip for pagination.
         * @param {number} take The number of categories to return per request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCategories(skip: number, take: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCategories200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCategories(skip, take, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoriesApi.getCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CategoriesApi - factory interface
 * @export
 */
export const CategoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CategoriesApiFp(configuration)
    return {
        /**
         * Retrieves categories from the database with pagination using skip and take query parameters.
         * @summary Fetch categories with pagination
         * @param {number} skip The number of categories to skip for pagination.
         * @param {number} take The number of categories to return per request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategories(skip: number, take: number, options?: RawAxiosRequestConfig): AxiosPromise<GetCategories200Response> {
            return localVarFp.getCategories(skip, take, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CategoriesApi - object-oriented interface
 * @export
 * @class CategoriesApi
 * @extends {BaseAPI}
 */
export class CategoriesApi extends BaseAPI {
    /**
     * Retrieves categories from the database with pagination using skip and take query parameters.
     * @summary Fetch categories with pagination
     * @param {number} skip The number of categories to skip for pagination.
     * @param {number} take The number of categories to return per request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public getCategories(skip: number, take: number, options?: RawAxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).getCategories(skip, take, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContactApi - axios parameter creator
 * @export
 */
export const ContactApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Submits a contact form with company details, contact information, and inquiry content. Stores the submission in the database and optionally sends a confirmation email.
         * @summary Submit a contact form inquiry
         * @param {SubmitContactFormRequest} submitContactFormRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitContactForm: async (submitContactFormRequest: SubmitContactFormRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'submitContactFormRequest' is not null or undefined
            assertParamExists('submitContactForm', 'submitContactFormRequest', submitContactFormRequest)
            const localVarPath = `/api/contact`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(submitContactFormRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContactApi - functional programming interface
 * @export
 */
export const ContactApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContactApiAxiosParamCreator(configuration)
    return {
        /**
         * Submits a contact form with company details, contact information, and inquiry content. Stores the submission in the database and optionally sends a confirmation email.
         * @summary Submit a contact form inquiry
         * @param {SubmitContactFormRequest} submitContactFormRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitContactForm(submitContactFormRequest: SubmitContactFormRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Created>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitContactForm(submitContactFormRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactApi.submitContactForm']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContactApi - factory interface
 * @export
 */
export const ContactApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContactApiFp(configuration)
    return {
        /**
         * Submits a contact form with company details, contact information, and inquiry content. Stores the submission in the database and optionally sends a confirmation email.
         * @summary Submit a contact form inquiry
         * @param {SubmitContactFormRequest} submitContactFormRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitContactForm(submitContactFormRequest: SubmitContactFormRequest, options?: RawAxiosRequestConfig): AxiosPromise<Created> {
            return localVarFp.submitContactForm(submitContactFormRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContactApi - object-oriented interface
 * @export
 * @class ContactApi
 * @extends {BaseAPI}
 */
export class ContactApi extends BaseAPI {
    /**
     * Submits a contact form with company details, contact information, and inquiry content. Stores the submission in the database and optionally sends a confirmation email.
     * @summary Submit a contact form inquiry
     * @param {SubmitContactFormRequest} submitContactFormRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    public submitContactForm(submitContactFormRequest: SubmitContactFormRequest, options?: RawAxiosRequestConfig) {
        return ContactApiFp(this.configuration).submitContactForm(submitContactFormRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



