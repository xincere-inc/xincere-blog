/* tslint:disable */
/* eslint-disable */
/**
 * Next.js API
 * API documentation for Next.js 15 application
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  BaseAPI,
  RequiredError,
  operationServerMap,
} from './base';

/**
 *
 * @export
 * @interface AdminCreateArticle201Response
 */
export interface AdminCreateArticle201Response {
  /**
   *
   * @type {string}
   * @memberof AdminCreateArticle201Response
   */
  message?: string;
}
/**
 *
 * @export
 * @interface AdminCreateArticle400Response
 */
export interface AdminCreateArticle400Response {
  /**
   *
   * @type {string}
   * @memberof AdminCreateArticle400Response
   */
  error?: string;
  /**
   *
   * @type {Array<AdminCreateArticle400ResponseErrorsInner>}
   * @memberof AdminCreateArticle400Response
   */
  errors?: Array<AdminCreateArticle400ResponseErrorsInner>;
}
/**
 *
 * @export
 * @interface AdminCreateArticle400ResponseErrorsInner
 */
export interface AdminCreateArticle400ResponseErrorsInner {
  /**
   *
   * @type {string}
   * @memberof AdminCreateArticle400ResponseErrorsInner
   */
  path?: string;
  /**
   *
   * @type {string}
   * @memberof AdminCreateArticle400ResponseErrorsInner
   */
  message?: string;
}
/**
 *
 * @export
 * @interface AdminCreateArticleRequest
 */
export interface AdminCreateArticleRequest {
  /**
   * The title of the article.
   * @type {string}
   * @memberof AdminCreateArticleRequest
   */
  title: string;
  /**
   * The unique slug for the article.
   * @type {string}
   * @memberof AdminCreateArticleRequest
   */
  slug: string;
  /**
   * A brief summary of the article.
   * @type {string}
   * @memberof AdminCreateArticleRequest
   */
  summary: string;
  /**
   * The HTML content of the article.
   * @type {string}
   * @memberof AdminCreateArticleRequest
   */
  content: string;
  /**
   * The markdown content of the article.
   * @type {string}
   * @memberof AdminCreateArticleRequest
   */
  markdownContent: string;
  /**
   * The ID of the category.
   * @type {number}
   * @memberof AdminCreateArticleRequest
   */
  categoryId: number;
  /**
   * The URL of the article\'s thumbnail image (optional).
   * @type {string}
   * @memberof AdminCreateArticleRequest
   */
  thumbnailUrl?: string | null;
  /**
   * The publication status of the article.
   * @type {string}
   * @memberof AdminCreateArticleRequest
   */
  status?: AdminCreateArticleRequestStatusEnum;
  /**
   * List of tag names to associate with the article (optional).
   * @type {Array<string>}
   * @memberof AdminCreateArticleRequest
   */
  tags?: Array<string>;
}

export const AdminCreateArticleRequestStatusEnum = {
  Draft: 'DRAFT',
  Published: 'PUBLISHED',
  Archived: 'ARCHIVED',
} as const;

export type AdminCreateArticleRequestStatusEnum =
  (typeof AdminCreateArticleRequestStatusEnum)[keyof typeof AdminCreateArticleRequestStatusEnum];

/**
 *
 * @export
 * @interface AdminCreateCategory201Response
 */
export interface AdminCreateCategory201Response {
  /**
   *
   * @type {string}
   * @memberof AdminCreateCategory201Response
   */
  message?: string;
  /**
   *
   * @type {AdminCreateCategory201ResponseCategory}
   * @memberof AdminCreateCategory201Response
   */
  category?: AdminCreateCategory201ResponseCategory;
}
/**
 *
 * @export
 * @interface AdminCreateCategory201ResponseCategory
 */
export interface AdminCreateCategory201ResponseCategory {
  /**
   * The unique identifier for the category.
   * @type {number}
   * @memberof AdminCreateCategory201ResponseCategory
   */
  id?: number;
  /**
   * The name of the category.
   * @type {string}
   * @memberof AdminCreateCategory201ResponseCategory
   */
  name?: string;
  /**
   * The unique slug for the category.
   * @type {string}
   * @memberof AdminCreateCategory201ResponseCategory
   */
  slug?: string;
  /**
   * The description of the category (optional).
   * @type {string}
   * @memberof AdminCreateCategory201ResponseCategory
   */
  description?: string | null;
  /**
   * The date and time when the category was created.
   * @type {string}
   * @memberof AdminCreateCategory201ResponseCategory
   */
  createdAt?: string;
  /**
   * The date and time when the category was last updated.
   * @type {string}
   * @memberof AdminCreateCategory201ResponseCategory
   */
  updatedAt?: string;
  /**
   * The date and time when the category was deleted (optional).
   * @type {string}
   * @memberof AdminCreateCategory201ResponseCategory
   */
  deletedAt?: string | null;
}
/**
 *
 * @export
 * @interface AdminCreateCategory400Response
 */
export interface AdminCreateCategory400Response {
  /**
   *
   * @type {string}
   * @memberof AdminCreateCategory400Response
   */
  error?: string;
}
/**
 *
 * @export
 * @interface AdminCreateCategoryRequest
 */
export interface AdminCreateCategoryRequest {
  /**
   * The name of the category.
   * @type {string}
   * @memberof AdminCreateCategoryRequest
   */
  name: string;
  /**
   * The unique slug for the category.
   * @type {string}
   * @memberof AdminCreateCategoryRequest
   */
  slug: string;
  /**
   * The description of the category (optional).
   * @type {string}
   * @memberof AdminCreateCategoryRequest
   */
  description?: string | null;
}
/**
 *
 * @export
 * @interface AdminCreateTag201Response
 */
export interface AdminCreateTag201Response {
  /**
   *
   * @type {string}
   * @memberof AdminCreateTag201Response
   */
  message?: string;
  /**
   *
   * @type {AdminCreateTag201ResponseTag}
   * @memberof AdminCreateTag201Response
   */
  tag?: AdminCreateTag201ResponseTag;
}
/**
 *
 * @export
 * @interface AdminCreateTag201ResponseTag
 */
export interface AdminCreateTag201ResponseTag {
  /**
   * The unique identifier for the tag.
   * @type {number}
   * @memberof AdminCreateTag201ResponseTag
   */
  id?: number;
  /**
   * The name of the tag.
   * @type {string}
   * @memberof AdminCreateTag201ResponseTag
   */
  name?: string;
  /**
   * The date and time when the tag was created.
   * @type {string}
   * @memberof AdminCreateTag201ResponseTag
   */
  createdAt?: string;
  /**
   * The date and time when the tag was last updated.
   * @type {string}
   * @memberof AdminCreateTag201ResponseTag
   */
  updatedAt?: string;
  /**
   * The date and time when the tag was deleted (optional).
   * @type {string}
   * @memberof AdminCreateTag201ResponseTag
   */
  deletedAt?: string | null;
}
/**
 *
 * @export
 * @interface AdminCreateTag400Response
 */
export interface AdminCreateTag400Response {
  /**
   *
   * @type {string}
   * @memberof AdminCreateTag400Response
   */
  error?: string;
}
/**
 *
 * @export
 * @interface AdminCreateTagRequest
 */
export interface AdminCreateTagRequest {
  /**
   * The unique name of the tag.
   * @type {string}
   * @memberof AdminCreateTagRequest
   */
  name: string;
}
/**
 *
 * @export
 * @interface AdminCreateUser400Response
 */
export interface AdminCreateUser400Response {
  /**
   *
   * @type {string}
   * @memberof AdminCreateUser400Response
   */
  error?: string;
}
/**
 *
 * @export
 * @interface AdminCreateUserRequest
 */
export interface AdminCreateUserRequest {
  /**
   *
   * @type {string}
   * @memberof AdminCreateUserRequest
   */
  firstName: string;
  /**
   *
   * @type {string}
   * @memberof AdminCreateUserRequest
   */
  lastName: string;
  /**
   *
   * @type {string}
   * @memberof AdminCreateUserRequest
   */
  country: string;
  /**
   *
   * @type {string}
   * @memberof AdminCreateUserRequest
   */
  gender?: AdminCreateUserRequestGenderEnum;
  /**
   *
   * @type {string}
   * @memberof AdminCreateUserRequest
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof AdminCreateUserRequest
   */
  password: string;
  /**
   *
   * @type {string}
   * @memberof AdminCreateUserRequest
   */
  phone?: string;
  /**
   *
   * @type {string}
   * @memberof AdminCreateUserRequest
   */
  address?: string;
  /**
   *
   * @type {string}
   * @memberof AdminCreateUserRequest
   */
  role?: string;
}

export const AdminCreateUserRequestGenderEnum = {
  Male: 'male',
  Female: 'female',
  Other: 'other',
} as const;

export type AdminCreateUserRequestGenderEnum =
  (typeof AdminCreateUserRequestGenderEnum)[keyof typeof AdminCreateUserRequestGenderEnum];

/**
 *
 * @export
 * @interface AdminDeleteArticles200Response
 */
export interface AdminDeleteArticles200Response {
  /**
   *
   * @type {string}
   * @memberof AdminDeleteArticles200Response
   */
  message?: string;
  /**
   *
   * @type {number}
   * @memberof AdminDeleteArticles200Response
   */
  count?: number;
}
/**
 *
 * @export
 * @interface AdminDeleteArticles404Response
 */
export interface AdminDeleteArticles404Response {
  /**
   *
   * @type {string}
   * @memberof AdminDeleteArticles404Response
   */
  message?: string;
}
/**
 *
 * @export
 * @interface AdminDeleteArticlesRequest
 */
export interface AdminDeleteArticlesRequest {
  /**
   *
   * @type {Array<number>}
   * @memberof AdminDeleteArticlesRequest
   */
  articleIds: Array<number>;
}
/**
 *
 * @export
 * @interface AdminDeleteCategoriesRequest
 */
export interface AdminDeleteCategoriesRequest {
  /**
   *
   * @type {Array<number>}
   * @memberof AdminDeleteCategoriesRequest
   */
  ids: Array<number>;
}
/**
 *
 * @export
 * @interface AdminDeleteUsersRequest
 */
export interface AdminDeleteUsersRequest {
  /**
   *
   * @type {Array<string>}
   * @memberof AdminDeleteUsersRequest
   */
  ids: Array<string>;
}
/**
 *
 * @export
 * @interface AdminGetArticles200Response
 */
export interface AdminGetArticles200Response {
  /**
   *
   * @type {Array<AdminGetArticles200ResponseDataInner>}
   * @memberof AdminGetArticles200Response
   */
  data?: Array<AdminGetArticles200ResponseDataInner>;
  /**
   *
   * @type {AdminGetArticles200ResponsePagination}
   * @memberof AdminGetArticles200Response
   */
  pagination?: AdminGetArticles200ResponsePagination;
}
/**
 *
 * @export
 * @interface AdminGetArticles200ResponseDataInner
 */
export interface AdminGetArticles200ResponseDataInner {
  /**
   * The unique identifier for the article.
   * @type {number}
   * @memberof AdminGetArticles200ResponseDataInner
   */
  id?: number;
  /**
   * The title of the article.
   * @type {string}
   * @memberof AdminGetArticles200ResponseDataInner
   */
  title?: string;
  /**
   * The unique slug for the article.
   * @type {string}
   * @memberof AdminGetArticles200ResponseDataInner
   */
  slug?: string;
  /**
   * A brief summary of the article.
   * @type {string}
   * @memberof AdminGetArticles200ResponseDataInner
   */
  summary?: string;
  /**
   * The HTML content of the article.
   * @type {string}
   * @memberof AdminGetArticles200ResponseDataInner
   */
  content?: string;
  /**
   * The markdown content of the article.
   * @type {string}
   * @memberof AdminGetArticles200ResponseDataInner
   */
  markdownContent?: string;
  /**
   * The URL of the article\'s thumbnail image.
   * @type {string}
   * @memberof AdminGetArticles200ResponseDataInner
   */
  thumbnailUrl?: string;
  /**
   * The publication status of the article.
   * @type {string}
   * @memberof AdminGetArticles200ResponseDataInner
   */
  status?: AdminGetArticles200ResponseDataInnerStatusEnum;
  /**
   * The date and time when the article was created.
   * @type {string}
   * @memberof AdminGetArticles200ResponseDataInner
   */
  createdAt?: string;
  /**
   * The date and time when the article was last updated.
   * @type {string}
   * @memberof AdminGetArticles200ResponseDataInner
   */
  updatedAt?: string;
  /**
   *
   * @type {AdminGetArticles200ResponseDataInnerAuthor}
   * @memberof AdminGetArticles200ResponseDataInner
   */
  author?: AdminGetArticles200ResponseDataInnerAuthor;
  /**
   *
   * @type {AdminGetArticles200ResponseDataInnerCategory}
   * @memberof AdminGetArticles200ResponseDataInner
   */
  category?: AdminGetArticles200ResponseDataInnerCategory;
  /**
   * List of tags associated with the article.
   * @type {Array<AdminGetArticles200ResponseDataInnerTagsInner>}
   * @memberof AdminGetArticles200ResponseDataInner
   */
  tags?: Array<AdminGetArticles200ResponseDataInnerTagsInner>;
}

export const AdminGetArticles200ResponseDataInnerStatusEnum = {
  Draft: 'DRAFT',
  Published: 'PUBLISHED',
  Archived: 'ARCHIVED',
} as const;

export type AdminGetArticles200ResponseDataInnerStatusEnum =
  (typeof AdminGetArticles200ResponseDataInnerStatusEnum)[keyof typeof AdminGetArticles200ResponseDataInnerStatusEnum];

/**
 *
 * @export
 * @interface AdminGetArticles200ResponseDataInnerAuthor
 */
export interface AdminGetArticles200ResponseDataInnerAuthor {
  /**
   * The unique identifier for the author.
   * @type {string}
   * @memberof AdminGetArticles200ResponseDataInnerAuthor
   */
  id?: string;
  /**
   * The name of the author.
   * @type {string}
   * @memberof AdminGetArticles200ResponseDataInnerAuthor
   */
  name?: string;
}
/**
 *
 * @export
 * @interface AdminGetArticles200ResponseDataInnerCategory
 */
export interface AdminGetArticles200ResponseDataInnerCategory {
  /**
   * The unique identifier for the category.
   * @type {number}
   * @memberof AdminGetArticles200ResponseDataInnerCategory
   */
  id?: number;
  /**
   * The name of the category.
   * @type {string}
   * @memberof AdminGetArticles200ResponseDataInnerCategory
   */
  name?: string;
}
/**
 *
 * @export
 * @interface AdminGetArticles200ResponseDataInnerTagsInner
 */
export interface AdminGetArticles200ResponseDataInnerTagsInner {
  /**
   * The unique identifier for the tag.
   * @type {number}
   * @memberof AdminGetArticles200ResponseDataInnerTagsInner
   */
  id?: number;
  /**
   * The name of the tag.
   * @type {string}
   * @memberof AdminGetArticles200ResponseDataInnerTagsInner
   */
  name?: string;
}
/**
 *
 * @export
 * @interface AdminGetArticles200ResponsePagination
 */
export interface AdminGetArticles200ResponsePagination {
  /**
   *
   * @type {number}
   * @memberof AdminGetArticles200ResponsePagination
   */
  page?: number;
  /**
   *
   * @type {number}
   * @memberof AdminGetArticles200ResponsePagination
   */
  limit?: number;
  /**
   *
   * @type {number}
   * @memberof AdminGetArticles200ResponsePagination
   */
  showPerPage?: number;
  /**
   *
   * @type {number}
   * @memberof AdminGetArticles200ResponsePagination
   */
  totalArticles?: number;
  /**
   *
   * @type {number}
   * @memberof AdminGetArticles200ResponsePagination
   */
  totalPages?: number;
}
/**
 *
 * @export
 * @interface AdminGetArticlesRequest
 */
export interface AdminGetArticlesRequest {
  /**
   * The page number for pagination.
   * @type {number}
   * @memberof AdminGetArticlesRequest
   */
  page?: number;
  /**
   * The number of articles to return per page.
   * @type {number}
   * @memberof AdminGetArticlesRequest
   */
  limit?: number;
  /**
   * Optional search term to filter articles by title, slug, summary, content, or status.
   * @type {string}
   * @memberof AdminGetArticlesRequest
   */
  search?: string;
}
/**
 *
 * @export
 * @interface AdminGetCategories200Response
 */
export interface AdminGetCategories200Response {
  /**
   *
   * @type {Array<AdminGetCategories200ResponseDataInner>}
   * @memberof AdminGetCategories200Response
   */
  data?: Array<AdminGetCategories200ResponseDataInner>;
  /**
   *
   * @type {AdminGetCategories200ResponsePagination}
   * @memberof AdminGetCategories200Response
   */
  pagination?: AdminGetCategories200ResponsePagination;
}
/**
 *
 * @export
 * @interface AdminGetCategories200ResponseDataInner
 */
export interface AdminGetCategories200ResponseDataInner {
  /**
   * The unique identifier for the category.
   * @type {number}
   * @memberof AdminGetCategories200ResponseDataInner
   */
  id?: number;
  /**
   * The name of the category.
   * @type {string}
   * @memberof AdminGetCategories200ResponseDataInner
   */
  name?: string;
  /**
   * The unique slug for the category.
   * @type {string}
   * @memberof AdminGetCategories200ResponseDataInner
   */
  slug?: string;
  /**
   * The description of the category (optional).
   * @type {string}
   * @memberof AdminGetCategories200ResponseDataInner
   */
  description?: string | null;
  /**
   * The date and time when the category was created.
   * @type {string}
   * @memberof AdminGetCategories200ResponseDataInner
   */
  createdAt?: string;
  /**
   * The date and time when the category was last updated.
   * @type {string}
   * @memberof AdminGetCategories200ResponseDataInner
   */
  updatedAt?: string;
  /**
   * The date and time when the category was deleted (optional).
   * @type {string}
   * @memberof AdminGetCategories200ResponseDataInner
   */
  deletedAt?: string | null;
}
/**
 *
 * @export
 * @interface AdminGetCategories200ResponsePagination
 */
export interface AdminGetCategories200ResponsePagination {
  /**
   *
   * @type {number}
   * @memberof AdminGetCategories200ResponsePagination
   */
  page?: number;
  /**
   *
   * @type {number}
   * @memberof AdminGetCategories200ResponsePagination
   */
  limit?: number;
  /**
   *
   * @type {number}
   * @memberof AdminGetCategories200ResponsePagination
   */
  showPerPage?: number;
  /**
   *
   * @type {number}
   * @memberof AdminGetCategories200ResponsePagination
   */
  totalCategories?: number;
  /**
   *
   * @type {number}
   * @memberof AdminGetCategories200ResponsePagination
   */
  totalPages?: number;
}
/**
 *
 * @export
 * @interface AdminGetContacts200Response
 */
export interface AdminGetContacts200Response {
  /**
   *
   * @type {Array<AdminGetContacts200ResponseDataInner>}
   * @memberof AdminGetContacts200Response
   */
  data?: Array<AdminGetContacts200ResponseDataInner>;
  /**
   *
   * @type {AdminGetContacts200ResponsePagination}
   * @memberof AdminGetContacts200Response
   */
  pagination?: AdminGetContacts200ResponsePagination;
}
/**
 *
 * @export
 * @interface AdminGetContacts200ResponseDataInner
 */
export interface AdminGetContacts200ResponseDataInner {
  /**
   * The unique identifier for the contact.
   * @type {number}
   * @memberof AdminGetContacts200ResponseDataInner
   */
  id?: number;
  /**
   * The name of the company.
   * @type {string}
   * @memberof AdminGetContacts200ResponseDataInner
   */
  companyName?: string;
  /**
   * The name of the contact person.
   * @type {string}
   * @memberof AdminGetContacts200ResponseDataInner
   */
  contactName?: string;
  /**
   * The email address of the contact person.
   * @type {string}
   * @memberof AdminGetContacts200ResponseDataInner
   */
  email?: string;
  /**
   * The phone number of the contact person.
   * @type {string}
   * @memberof AdminGetContacts200ResponseDataInner
   */
  phone?: string;
  /**
   * The content of the inquiry.
   * @type {string}
   * @memberof AdminGetContacts200ResponseDataInner
   */
  inquiry?: string;
  /**
   * The status of the contact.
   * @type {string}
   * @memberof AdminGetContacts200ResponseDataInner
   */
  status?: string;
  /**
   * Agreement to the privacy policy.
   * @type {boolean}
   * @memberof AdminGetContacts200ResponseDataInner
   */
  privacyPolicy?: boolean;
  /**
   * The date and time when the contact was created.
   * @type {string}
   * @memberof AdminGetContacts200ResponseDataInner
   */
  createdAt?: string;
}
/**
 *
 * @export
 * @interface AdminGetContacts200ResponsePagination
 */
export interface AdminGetContacts200ResponsePagination {
  /**
   *
   * @type {number}
   * @memberof AdminGetContacts200ResponsePagination
   */
  page?: number;
  /**
   *
   * @type {number}
   * @memberof AdminGetContacts200ResponsePagination
   */
  limit?: number;
  /**
   *
   * @type {number}
   * @memberof AdminGetContacts200ResponsePagination
   */
  showPerPage?: number;
  /**
   *
   * @type {number}
   * @memberof AdminGetContacts200ResponsePagination
   */
  totalContacts?: number;
  /**
   *
   * @type {number}
   * @memberof AdminGetContacts200ResponsePagination
   */
  totalPages?: number;
}
/**
 *
 * @export
 * @interface AdminGetTags200Response
 */
export interface AdminGetTags200Response {
  /**
   *
   * @type {Array<AdminCreateTag201ResponseTag>}
   * @memberof AdminGetTags200Response
   */
  data?: Array<AdminCreateTag201ResponseTag>;
  /**
   *
   * @type {AdminGetTags200ResponsePagination}
   * @memberof AdminGetTags200Response
   */
  pagination?: AdminGetTags200ResponsePagination;
}
/**
 *
 * @export
 * @interface AdminGetTags200ResponsePagination
 */
export interface AdminGetTags200ResponsePagination {
  /**
   *
   * @type {number}
   * @memberof AdminGetTags200ResponsePagination
   */
  page?: number;
  /**
   *
   * @type {number}
   * @memberof AdminGetTags200ResponsePagination
   */
  limit?: number;
  /**
   *
   * @type {number}
   * @memberof AdminGetTags200ResponsePagination
   */
  showPerPage?: number;
  /**
   *
   * @type {number}
   * @memberof AdminGetTags200ResponsePagination
   */
  totalTags?: number;
  /**
   *
   * @type {number}
   * @memberof AdminGetTags200ResponsePagination
   */
  totalPages?: number;
}
/**
 *
 * @export
 * @interface AdminGetUsers200Response
 */
export interface AdminGetUsers200Response {
  /**
   *
   * @type {Array<AdminGetUsers200ResponseDataInner>}
   * @memberof AdminGetUsers200Response
   */
  data?: Array<AdminGetUsers200ResponseDataInner>;
  /**
   *
   * @type {AdminGetUsers200ResponsePagination}
   * @memberof AdminGetUsers200Response
   */
  pagination?: AdminGetUsers200ResponsePagination;
}
/**
 *
 * @export
 * @interface AdminGetUsers200ResponseDataInner
 */
export interface AdminGetUsers200ResponseDataInner {
  /**
   *
   * @type {string}
   * @memberof AdminGetUsers200ResponseDataInner
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof AdminGetUsers200ResponseDataInner
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof AdminGetUsers200ResponseDataInner
   */
  firstName?: string;
  /**
   *
   * @type {string}
   * @memberof AdminGetUsers200ResponseDataInner
   */
  lastName?: string;
  /**
   *
   * @type {string}
   * @memberof AdminGetUsers200ResponseDataInner
   */
  country?: string;
  /**
   *
   * @type {string}
   * @memberof AdminGetUsers200ResponseDataInner
   */
  address?: string;
  /**
   *
   * @type {string}
   * @memberof AdminGetUsers200ResponseDataInner
   */
  phone?: string;
  /**
   *
   * @type {string}
   * @memberof AdminGetUsers200ResponseDataInner
   */
  role?: string;
}
/**
 *
 * @export
 * @interface AdminGetUsers200ResponsePagination
 */
export interface AdminGetUsers200ResponsePagination {
  /**
   *
   * @type {number}
   * @memberof AdminGetUsers200ResponsePagination
   */
  page?: number;
  /**
   *
   * @type {number}
   * @memberof AdminGetUsers200ResponsePagination
   */
  limit?: number;
  /**
   *
   * @type {number}
   * @memberof AdminGetUsers200ResponsePagination
   */
  showPerPage?: number;
  /**
   *
   * @type {number}
   * @memberof AdminGetUsers200ResponsePagination
   */
  totalUsers?: number;
  /**
   *
   * @type {number}
   * @memberof AdminGetUsers200ResponsePagination
   */
  totalPages?: number;
}
/**
 *
 * @export
 * @interface AdminGetUsers400Response
 */
export interface AdminGetUsers400Response {
  /**
   *
   * @type {string}
   * @memberof AdminGetUsers400Response
   */
  error?: string;
  /**
   *
   * @type {Array<AdminGetUsers400ResponseErrorsInner>}
   * @memberof AdminGetUsers400Response
   */
  errors?: Array<AdminGetUsers400ResponseErrorsInner>;
}
/**
 *
 * @export
 * @interface AdminGetUsers400ResponseErrorsInner
 */
export interface AdminGetUsers400ResponseErrorsInner {
  /**
   *
   * @type {string}
   * @memberof AdminGetUsers400ResponseErrorsInner
   */
  path?: string;
  /**
   *
   * @type {string}
   * @memberof AdminGetUsers400ResponseErrorsInner
   */
  message?: string;
}
/**
 *
 * @export
 * @interface AdminGetUsersRequest
 */
export interface AdminGetUsersRequest {
  /**
   *
   * @type {number}
   * @memberof AdminGetUsersRequest
   */
  page?: number;
  /**
   *
   * @type {number}
   * @memberof AdminGetUsersRequest
   */
  limit?: number;
  /**
   *
   * @type {string}
   * @memberof AdminGetUsersRequest
   */
  search?: string;
}
/**
 *
 * @export
 * @interface AdminUpdateArticle200Response
 */
export interface AdminUpdateArticle200Response {
  /**
   *
   * @type {string}
   * @memberof AdminUpdateArticle200Response
   */
  message?: string;
}
/**
 *
 * @export
 * @interface AdminUpdateArticleRequest
 */
export interface AdminUpdateArticleRequest {
  /**
   * The ID of the article to update.
   * @type {number}
   * @memberof AdminUpdateArticleRequest
   */
  id: number;
  /**
   * The title of the article.
   * @type {string}
   * @memberof AdminUpdateArticleRequest
   */
  title?: string;
  /**
   * The unique slug for the article.
   * @type {string}
   * @memberof AdminUpdateArticleRequest
   */
  slug?: string;
  /**
   * A brief summary of the article.
   * @type {string}
   * @memberof AdminUpdateArticleRequest
   */
  summary?: string;
  /**
   * The HTML content of the article.
   * @type {string}
   * @memberof AdminUpdateArticleRequest
   */
  content?: string;
  /**
   * The markdown content of the article.
   * @type {string}
   * @memberof AdminUpdateArticleRequest
   */
  markdownContent?: string;
  /**
   * The ID of the category.
   * @type {number}
   * @memberof AdminUpdateArticleRequest
   */
  categoryId?: number;
  /**
   * The ID of the author.
   * @type {string}
   * @memberof AdminUpdateArticleRequest
   */
  authorId?: string;
  /**
   * The URL of the article\'s thumbnail image (optional).
   * @type {string}
   * @memberof AdminUpdateArticleRequest
   */
  thumbnailUrl?: string | null;
  /**
   * The publication status of the article.
   * @type {string}
   * @memberof AdminUpdateArticleRequest
   */
  status?: AdminUpdateArticleRequestStatusEnum;
  /**
   * List of tag names to associate with the article (optional). All tag associations will be replaced.
   * @type {Array<string>}
   * @memberof AdminUpdateArticleRequest
   */
  tags?: Array<string>;
}

export const AdminUpdateArticleRequestStatusEnum = {
  Draft: 'DRAFT',
  Published: 'PUBLISHED',
  Archived: 'ARCHIVED',
} as const;

export type AdminUpdateArticleRequestStatusEnum =
  (typeof AdminUpdateArticleRequestStatusEnum)[keyof typeof AdminUpdateArticleRequestStatusEnum];

/**
 *
 * @export
 * @interface AdminUpdateCategory200Response
 */
export interface AdminUpdateCategory200Response {
  /**
   *
   * @type {string}
   * @memberof AdminUpdateCategory200Response
   */
  message?: string;
  /**
   *
   * @type {AdminCreateCategory201ResponseCategory}
   * @memberof AdminUpdateCategory200Response
   */
  category?: AdminCreateCategory201ResponseCategory;
}
/**
 *
 * @export
 * @interface AdminUpdateCategoryRequest
 */
export interface AdminUpdateCategoryRequest {
  /**
   * The ID of the category to update.
   * @type {number}
   * @memberof AdminUpdateCategoryRequest
   */
  id: number;
  /**
   * The name of the category.
   * @type {string}
   * @memberof AdminUpdateCategoryRequest
   */
  name?: string;
  /**
   * The unique slug for the category.
   * @type {string}
   * @memberof AdminUpdateCategoryRequest
   */
  slug?: string;
  /**
   * The description of the category (optional).
   * @type {string}
   * @memberof AdminUpdateCategoryRequest
   */
  description?: string | null;
}
/**
 *
 * @export
 * @interface AdminUpdateContact200Response
 */
export interface AdminUpdateContact200Response {
  /**
   *
   * @type {string}
   * @memberof AdminUpdateContact200Response
   */
  message?: string;
  /**
   *
   * @type {AdminUpdateContact200ResponseContact}
   * @memberof AdminUpdateContact200Response
   */
  contact?: AdminUpdateContact200ResponseContact;
}
/**
 *
 * @export
 * @interface AdminUpdateContact200ResponseContact
 */
export interface AdminUpdateContact200ResponseContact {
  /**
   *
   * @type {number}
   * @memberof AdminUpdateContact200ResponseContact
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof AdminUpdateContact200ResponseContact
   */
  status?: AdminUpdateContact200ResponseContactStatusEnum;
}

export const AdminUpdateContact200ResponseContactStatusEnum = {
  Open: 'OPEN',
  Inprogress: 'INPROGRESS',
  Closed: 'CLOSED',
} as const;

export type AdminUpdateContact200ResponseContactStatusEnum =
  (typeof AdminUpdateContact200ResponseContactStatusEnum)[keyof typeof AdminUpdateContact200ResponseContactStatusEnum];

/**
 *
 * @export
 * @interface AdminUpdateContactRequest
 */
export interface AdminUpdateContactRequest {
  /**
   * The ID of the contact to update.
   * @type {number}
   * @memberof AdminUpdateContactRequest
   */
  id: number;
  /**
   * The new status for the contact.
   * @type {string}
   * @memberof AdminUpdateContactRequest
   */
  status: AdminUpdateContactRequestStatusEnum;
}

export const AdminUpdateContactRequestStatusEnum = {
  Open: 'OPEN',
  Inprogress: 'INPROGRESS',
  Closed: 'CLOSED',
} as const;

export type AdminUpdateContactRequestStatusEnum =
  (typeof AdminUpdateContactRequestStatusEnum)[keyof typeof AdminUpdateContactRequestStatusEnum];

/**
 *
 * @export
 * @interface AdminUpdateTag200Response
 */
export interface AdminUpdateTag200Response {
  /**
   *
   * @type {string}
   * @memberof AdminUpdateTag200Response
   */
  message?: string;
  /**
   *
   * @type {AdminCreateTag201ResponseTag}
   * @memberof AdminUpdateTag200Response
   */
  tag?: AdminCreateTag201ResponseTag;
}
/**
 *
 * @export
 * @interface AdminUpdateTagRequest
 */
export interface AdminUpdateTagRequest {
  /**
   * The ID of the tag to update.
   * @type {number}
   * @memberof AdminUpdateTagRequest
   */
  id: number;
  /**
   * The name of the tag.
   * @type {string}
   * @memberof AdminUpdateTagRequest
   */
  name?: string;
}
/**
 *
 * @export
 * @interface AdminUpdateUser200Response
 */
export interface AdminUpdateUser200Response {
  /**
   *
   * @type {string}
   * @memberof AdminUpdateUser200Response
   */
  message?: string;
  /**
   *
   * @type {AdminUpdateUser200ResponseUser}
   * @memberof AdminUpdateUser200Response
   */
  user?: AdminUpdateUser200ResponseUser;
}
/**
 *
 * @export
 * @interface AdminUpdateUser200ResponseUser
 */
export interface AdminUpdateUser200ResponseUser {
  /**
   *
   * @type {string}
   * @memberof AdminUpdateUser200ResponseUser
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof AdminUpdateUser200ResponseUser
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof AdminUpdateUser200ResponseUser
   */
  firstName?: string;
  /**
   *
   * @type {string}
   * @memberof AdminUpdateUser200ResponseUser
   */
  lastName?: string;
  /**
   *
   * @type {string}
   * @memberof AdminUpdateUser200ResponseUser
   */
  address?: string;
  /**
   *
   * @type {string}
   * @memberof AdminUpdateUser200ResponseUser
   */
  phone?: string;
  /**
   *
   * @type {string}
   * @memberof AdminUpdateUser200ResponseUser
   */
  role?: AdminUpdateUser200ResponseUserRoleEnum;
  /**
   *
   * @type {string}
   * @memberof AdminUpdateUser200ResponseUser
   */
  country?: string;
}

export const AdminUpdateUser200ResponseUserRoleEnum = {
  User: 'USER',
  Admin: 'ADMIN',
} as const;

export type AdminUpdateUser200ResponseUserRoleEnum =
  (typeof AdminUpdateUser200ResponseUserRoleEnum)[keyof typeof AdminUpdateUser200ResponseUserRoleEnum];

/**
 *
 * @export
 * @interface AdminUpdateUser400Response
 */
export interface AdminUpdateUser400Response {
  /**
   *
   * @type {string}
   * @memberof AdminUpdateUser400Response
   */
  error?: string;
  /**
   *
   * @type {Array<AdminUpdateUser400ResponseErrorsInner>}
   * @memberof AdminUpdateUser400Response
   */
  errors?: Array<AdminUpdateUser400ResponseErrorsInner>;
}
/**
 *
 * @export
 * @interface AdminUpdateUser400ResponseErrorsInner
 */
export interface AdminUpdateUser400ResponseErrorsInner {
  /**
   *
   * @type {string}
   * @memberof AdminUpdateUser400ResponseErrorsInner
   */
  path?: string;
  /**
   *
   * @type {string}
   * @memberof AdminUpdateUser400ResponseErrorsInner
   */
  message?: string;
}
/**
 *
 * @export
 * @interface AdminUpdateUser404Response
 */
export interface AdminUpdateUser404Response {
  /**
   *
   * @type {string}
   * @memberof AdminUpdateUser404Response
   */
  error?: string;
}
/**
 *
 * @export
 * @interface AdminUpdateUser500Response
 */
export interface AdminUpdateUser500Response {
  /**
   *
   * @type {string}
   * @memberof AdminUpdateUser500Response
   */
  error?: string;
  /**
   *
   * @type {string}
   * @memberof AdminUpdateUser500Response
   */
  message?: string;
}
/**
 *
 * @export
 * @interface AdminUpdateUserRequest
 */
export interface AdminUpdateUserRequest {
  /**
   * The ID of the user to update.
   * @type {string}
   * @memberof AdminUpdateUserRequest
   */
  id: string;
  /**
   * The email address of the user.
   * @type {string}
   * @memberof AdminUpdateUserRequest
   */
  email?: string;
  /**
   * The first name of the user.
   * @type {string}
   * @memberof AdminUpdateUserRequest
   */
  firstName?: string;
  /**
   * The last name of the user.
   * @type {string}
   * @memberof AdminUpdateUserRequest
   */
  lastName?: string;
  /**
   * The address of the user.
   * @type {string}
   * @memberof AdminUpdateUserRequest
   */
  address?: string;
  /**
   * The phone number of the user.
   * @type {string}
   * @memberof AdminUpdateUserRequest
   */
  phone?: string;
  /**
   * The role of the user.
   * @type {string}
   * @memberof AdminUpdateUserRequest
   */
  role?: AdminUpdateUserRequestRoleEnum;
  /**
   * The country of the user.
   * @type {string}
   * @memberof AdminUpdateUserRequest
   */
  country?: string;
}

export const AdminUpdateUserRequestRoleEnum = {
  User: 'user',
  Admin: 'admin',
} as const;

export type AdminUpdateUserRequestRoleEnum =
  (typeof AdminUpdateUserRequestRoleEnum)[keyof typeof AdminUpdateUserRequestRoleEnum];

/**
 *
 * @export
 * @interface ChangePassword400Response
 */
export interface ChangePassword400Response {
  /**
   *
   * @type {string}
   * @memberof ChangePassword400Response
   */
  error?: string;
  /**
   *
   * @type {Array<ChangePassword400ResponseDetailsInner>}
   * @memberof ChangePassword400Response
   */
  details?: Array<ChangePassword400ResponseDetailsInner>;
}
/**
 *
 * @export
 * @interface ChangePassword400ResponseDetailsInner
 */
export interface ChangePassword400ResponseDetailsInner {
  /**
   *
   * @type {Array<string>}
   * @memberof ChangePassword400ResponseDetailsInner
   */
  path?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof ChangePassword400ResponseDetailsInner
   */
  message?: string;
}
/**
 *
 * @export
 * @interface ChangePassword401Response
 */
export interface ChangePassword401Response {
  /**
   *
   * @type {string}
   * @memberof ChangePassword401Response
   */
  error?: string;
}
/**
 *
 * @export
 * @interface ChangePasswordRequest
 */
export interface ChangePasswordRequest {
  /**
   *
   * @type {string}
   * @memberof ChangePasswordRequest
   */
  oldPassword: string;
  /**
   *
   * @type {string}
   * @memberof ChangePasswordRequest
   */
  newPassword: string;
}
/**
 *
 * @export
 * @interface Created
 */
export interface Created {
  /**
   *
   * @type {string}
   * @memberof Created
   */
  message: string;
}
/**
 *
 * @export
 * @interface CreatedWithId
 */
export interface CreatedWithId {
  /**
   *
   * @type {string}
   * @memberof CreatedWithId
   */
  message: string;
  /**
   *
   * @type {number}
   * @memberof CreatedWithId
   */
  id: number;
}
/**
 *
 * @export
 * @interface ForbiddenError
 */
export interface ForbiddenError {
  /**
   *
   * @type {string}
   * @memberof ForbiddenError
   */
  error?: string;
  /**
   *
   * @type {string}
   * @memberof ForbiddenError
   */
  message?: string;
}
/**
 *
 * @export
 * @interface ForgetPassword400Response
 */
export interface ForgetPassword400Response {
  /**
   *
   * @type {string}
   * @memberof ForgetPassword400Response
   */
  error?: string;
  /**
   *
   * @type {Array<ChangePassword400ResponseDetailsInner>}
   * @memberof ForgetPassword400Response
   */
  details?: Array<ChangePassword400ResponseDetailsInner>;
}
/**
 *
 * @export
 * @interface ForgetPassword404Response
 */
export interface ForgetPassword404Response {
  /**
   *
   * @type {string}
   * @memberof ForgetPassword404Response
   */
  error?: string;
}
/**
 *
 * @export
 * @interface ForgetPassword429Response
 */
export interface ForgetPassword429Response {
  /**
   *
   * @type {string}
   * @memberof ForgetPassword429Response
   */
  error?: string;
}
/**
 *
 * @export
 * @interface ForgetPasswordRequest
 */
export interface ForgetPasswordRequest {
  /**
   *
   * @type {string}
   * @memberof ForgetPasswordRequest
   */
  email: string;
}
/**
 *
 * @export
 * @interface GetArticles200Response
 */
export interface GetArticles200Response {
  /**
   *
   * @type {string}
   * @memberof GetArticles200Response
   */
  message?: string;
  /**
   * The total number of articles matching the query.
   * @type {number}
   * @memberof GetArticles200Response
   */
  total?: number;
  /**
   *
   * @type {Array<GetArticles200ResponseArticlesInner>}
   * @memberof GetArticles200Response
   */
  articles?: Array<GetArticles200ResponseArticlesInner>;
}
/**
 *
 * @export
 * @interface GetArticles200ResponseArticlesInner
 */
export interface GetArticles200ResponseArticlesInner {
  /**
   * The unique identifier for the article.
   * @type {number}
   * @memberof GetArticles200ResponseArticlesInner
   */
  id?: number;
  /**
   * The title of the article.
   * @type {string}
   * @memberof GetArticles200ResponseArticlesInner
   */
  title?: string;
  /**
   * The unique slug for the article.
   * @type {string}
   * @memberof GetArticles200ResponseArticlesInner
   */
  slug?: string;
  /**
   * A brief summary of the article.
   * @type {string}
   * @memberof GetArticles200ResponseArticlesInner
   */
  summary?: string;
  /**
   * The URL of the article\'s thumbnail image (optional).
   * @type {string}
   * @memberof GetArticles200ResponseArticlesInner
   */
  thumbnailUrl?: string | null;
  /**
   * The publication status of the article.
   * @type {string}
   * @memberof GetArticles200ResponseArticlesInner
   */
  status?: GetArticles200ResponseArticlesInnerStatusEnum;
  /**
   *
   * @type {GetArticles200ResponseArticlesInnerAuthor}
   * @memberof GetArticles200ResponseArticlesInner
   */
  author?: GetArticles200ResponseArticlesInnerAuthor;
  /**
   *
   * @type {GetArticles200ResponseArticlesInnerCategory}
   * @memberof GetArticles200ResponseArticlesInner
   */
  category?: GetArticles200ResponseArticlesInnerCategory;
  /**
   * The date and time when the article was created.
   * @type {string}
   * @memberof GetArticles200ResponseArticlesInner
   */
  createdAt?: string;
  /**
   * The date and time when the article was last updated.
   * @type {string}
   * @memberof GetArticles200ResponseArticlesInner
   */
  updatedAt?: string;
  /**
   * The date and time when the article was deleted (optional).
   * @type {string}
   * @memberof GetArticles200ResponseArticlesInner
   */
  deletedAt?: string | null;
}

export const GetArticles200ResponseArticlesInnerStatusEnum = {
  Draft: 'DRAFT',
  Published: 'PUBLISHED',
  Archived: 'ARCHIVED',
} as const;

export type GetArticles200ResponseArticlesInnerStatusEnum =
  (typeof GetArticles200ResponseArticlesInnerStatusEnum)[keyof typeof GetArticles200ResponseArticlesInnerStatusEnum];

/**
 * The author of the article.
 * @export
 * @interface GetArticles200ResponseArticlesInnerAuthor
 */
export interface GetArticles200ResponseArticlesInnerAuthor {
  /**
   * The unique identifier for the author.
   * @type {string}
   * @memberof GetArticles200ResponseArticlesInnerAuthor
   */
  id?: string;
  /**
   * The name of the author (optional, assuming Author model has a name field).
   * @type {string}
   * @memberof GetArticles200ResponseArticlesInnerAuthor
   */
  name?: string;
}
/**
 * The category of the article.
 * @export
 * @interface GetArticles200ResponseArticlesInnerCategory
 */
export interface GetArticles200ResponseArticlesInnerCategory {
  /**
   * The unique identifier for the category.
   * @type {number}
   * @memberof GetArticles200ResponseArticlesInnerCategory
   */
  id?: number;
  /**
   * The name of the category.
   * @type {string}
   * @memberof GetArticles200ResponseArticlesInnerCategory
   */
  name?: string;
  /**
   * The unique slug for the category.
   * @type {string}
   * @memberof GetArticles200ResponseArticlesInnerCategory
   */
  slug?: string;
}
/**
 *
 * @export
 * @interface GetCategories200Response
 */
export interface GetCategories200Response {
  /**
   *
   * @type {string}
   * @memberof GetCategories200Response
   */
  message?: string;
  /**
   *
   * @type {Array<AdminGetCategories200ResponseDataInner>}
   * @memberof GetCategories200Response
   */
  categories?: Array<AdminGetCategories200ResponseDataInner>;
}
/**
 *
 * @export
 * @interface IncrementArticleViewCount200Response
 */
export interface IncrementArticleViewCount200Response {
  /**
   * The updated view count for the article.
   * @type {number}
   * @memberof IncrementArticleViewCount200Response
   */
  viewsCount?: number;
}
/**
 *
 * @export
 * @interface IncrementArticleViewCount400Response
 */
export interface IncrementArticleViewCount400Response {
  /**
   *
   * @type {string}
   * @memberof IncrementArticleViewCount400Response
   */
  error?: string;
}
/**
 *
 * @export
 * @interface IncrementArticleViewCount404Response
 */
export interface IncrementArticleViewCount404Response {
  /**
   *
   * @type {string}
   * @memberof IncrementArticleViewCount404Response
   */
  error?: string;
}
/**
 *
 * @export
 * @interface InternalServerError
 */
export interface InternalServerError {
  /**
   *
   * @type {string}
   * @memberof InternalServerError
   */
  error?: string;
  /**
   *
   * @type {string}
   * @memberof InternalServerError
   */
  message?: string;
}
/**
 *
 * @export
 * @interface NotFoundError
 */
export interface NotFoundError {
  /**
   *
   * @type {string}
   * @memberof NotFoundError
   */
  error?: string;
  /**
   *
   * @type {string}
   * @memberof NotFoundError
   */
  message?: string;
}
/**
 *
 * @export
 * @interface RegisterRequest
 */
export interface RegisterRequest {
  /**
   *
   * @type {string}
   * @memberof RegisterRequest
   */
  firstName: string;
  /**
   *
   * @type {string}
   * @memberof RegisterRequest
   */
  lastName?: string;
  /**
   *
   * @type {string}
   * @memberof RegisterRequest
   */
  country?: string;
  /**
   *
   * @type {string}
   * @memberof RegisterRequest
   */
  gender: RegisterRequestGenderEnum;
  /**
   *
   * @type {string}
   * @memberof RegisterRequest
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof RegisterRequest
   */
  password: string;
  /**
   *
   * @type {string}
   * @memberof RegisterRequest
   */
  confirmPassword: string;
}

export const RegisterRequestGenderEnum = {
  Male: 'male',
  Female: 'female',
  Other: 'other',
} as const;

export type RegisterRequestGenderEnum =
  (typeof RegisterRequestGenderEnum)[keyof typeof RegisterRequestGenderEnum];

/**
 *
 * @export
 * @interface ResetPassword400Response
 */
export interface ResetPassword400Response {
  /**
   *
   * @type {string}
   * @memberof ResetPassword400Response
   */
  error?: string;
}
/**
 *
 * @export
 * @interface ResetPasswordRequest
 */
export interface ResetPasswordRequest {
  /**
   *
   * @type {string}
   * @memberof ResetPasswordRequest
   */
  token: string;
  /**
   *
   * @type {string}
   * @memberof ResetPasswordRequest
   */
  newPassword: string;
}
/**
 *
 * @export
 * @interface SubmitContactFormRequest
 */
export interface SubmitContactFormRequest {
  /**
   * The name of the company submitting the contact form.
   * @type {string}
   * @memberof SubmitContactFormRequest
   */
  companyName: string;
  /**
   * The name of the contact person submitting the form.
   * @type {string}
   * @memberof SubmitContactFormRequest
   */
  contactName: string;
  /**
   * The email address of the contact person.
   * @type {string}
   * @memberof SubmitContactFormRequest
   */
  email: string;
  /**
   * The phone number of the contact person.
   * @type {string}
   * @memberof SubmitContactFormRequest
   */
  phone: string;
  /**
   * The content of the inquiry or message.
   * @type {string}
   * @memberof SubmitContactFormRequest
   */
  inquiry: string;
  /**
   * Indicates whether the user agrees to the privacy policy.
   * @type {boolean}
   * @memberof SubmitContactFormRequest
   */
  privacyPolicy: boolean;
}
/**
 *
 * @export
 * @interface Success
 */
export interface Success {
  /**
   *
   * @type {string}
   * @memberof Success
   */
  message: string;
}
/**
 *
 * @export
 * @interface UnAuthorizedError
 */
export interface UnAuthorizedError {
  /**
   *
   * @type {string}
   * @memberof UnAuthorizedError
   */
  error?: string;
  /**
   *
   * @type {string}
   * @memberof UnAuthorizedError
   */
  message?: string;
}
/**
 *
 * @export
 * @interface UnprocessableEntity
 */
export interface UnprocessableEntity {
  /**
   *
   * @type {string}
   * @memberof UnprocessableEntity
   */
  error?: string;
  /**
   *
   * @type {string}
   * @memberof UnprocessableEntity
   */
  message?: string;
}
/**
 *
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
  /**
   *
   * @type {string}
   * @memberof ValidationError
   */
  error?: string;
  /**
   *
   * @type {Array<ValidationErrorErrorsInner>}
   * @memberof ValidationError
   */
  errors?: Array<ValidationErrorErrorsInner>;
}
/**
 *
 * @export
 * @interface ValidationErrorErrorsInner
 */
export interface ValidationErrorErrorsInner {
  /**
   *
   * @type {string}
   * @memberof ValidationErrorErrorsInner
   */
  path?: string;
  /**
   *
   * @type {string}
   * @memberof ValidationErrorErrorsInner
   */
  message?: string;
}
/**
 *
 * @export
 * @interface VerifyEmail400Response
 */
export interface VerifyEmail400Response {
  /**
   *
   * @type {string}
   * @memberof VerifyEmail400Response
   */
  error?: string;
  /**
   *
   * @type {string}
   * @memberof VerifyEmail400Response
   */
  message?: string;
}

/**
 * AdminApi - axios parameter creator
 * @export
 */
export const AdminApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Creates a new article with a unique slug. Tags will be created if they do not exist and linked to the article. The first author in the database will be assigned.
     * @summary Create a new article
     * @param {AdminCreateArticleRequest} adminCreateArticleRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminCreateArticle: async (
      adminCreateArticleRequest: AdminCreateArticleRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'adminCreateArticleRequest' is not null or undefined
      assertParamExists(
        'adminCreateArticle',
        'adminCreateArticleRequest',
        adminCreateArticleRequest
      );
      const localVarPath = `/api/admin/articles/create-article`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication jwt required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        adminCreateArticleRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Creates a new category with a unique name and slug.
     * @summary Create a new category
     * @param {AdminCreateCategoryRequest} adminCreateCategoryRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminCreateCategory: async (
      adminCreateCategoryRequest: AdminCreateCategoryRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'adminCreateCategoryRequest' is not null or undefined
      assertParamExists(
        'adminCreateCategory',
        'adminCreateCategoryRequest',
        adminCreateCategoryRequest
      );
      const localVarPath = `/api/admin/categories/create-category`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication jwt required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        adminCreateCategoryRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Creates a new tag with a unique name.
     * @summary Create a new tag
     * @param {AdminCreateTagRequest} adminCreateTagRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminCreateTag: async (
      adminCreateTagRequest: AdminCreateTagRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'adminCreateTagRequest' is not null or undefined
      assertParamExists(
        'adminCreateTag',
        'adminCreateTagRequest',
        adminCreateTagRequest
      );
      const localVarPath = `/api/admin/tags/create-tag`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication jwt required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        adminCreateTagRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Creates a new user, hashes their password, generates an email verification token, and sends a verification email.
     * @summary Register a new user
     * @param {AdminCreateUserRequest} adminCreateUserRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminCreateUser: async (
      adminCreateUserRequest: AdminCreateUserRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'adminCreateUserRequest' is not null or undefined
      assertParamExists(
        'adminCreateUser',
        'adminCreateUserRequest',
        adminCreateUserRequest
      );
      const localVarPath = `/api/admin/users/create-user`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        adminCreateUserRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Deletes articles by their IDs (soft delete, sets deletedAt). Also removes associated tags.
     * @summary Delete articles by IDs (soft delete)
     * @param {AdminDeleteArticlesRequest} adminDeleteArticlesRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminDeleteArticles: async (
      adminDeleteArticlesRequest: AdminDeleteArticlesRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'adminDeleteArticlesRequest' is not null or undefined
      assertParamExists(
        'adminDeleteArticles',
        'adminDeleteArticlesRequest',
        adminDeleteArticlesRequest
      );
      const localVarPath = `/api/admin/articles/delete-article`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication jwt required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        adminDeleteArticlesRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Deletes categories by their IDs (soft delete, sets deletedAt).
     * @summary Delete categories by IDs
     * @param {AdminDeleteCategoriesRequest} adminDeleteCategoriesRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminDeleteCategories: async (
      adminDeleteCategoriesRequest: AdminDeleteCategoriesRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'adminDeleteCategoriesRequest' is not null or undefined
      assertParamExists(
        'adminDeleteCategories',
        'adminDeleteCategoriesRequest',
        adminDeleteCategoriesRequest
      );
      const localVarPath = `/api/admin/categories/delete-category`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication jwt required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        adminDeleteCategoriesRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Deletes contacts by their IDs.
     * @summary Delete contacts by IDs
     * @param {AdminDeleteCategoriesRequest} adminDeleteCategoriesRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminDeleteContacts: async (
      adminDeleteCategoriesRequest: AdminDeleteCategoriesRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'adminDeleteCategoriesRequest' is not null or undefined
      assertParamExists(
        'adminDeleteContacts',
        'adminDeleteCategoriesRequest',
        adminDeleteCategoriesRequest
      );
      const localVarPath = `/api/admin/contacts/delete-contact`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication jwt required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        adminDeleteCategoriesRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Deletes tags by their IDs (soft delete, sets deletedAt).
     * @summary Delete tags by IDs
     * @param {AdminDeleteCategoriesRequest} adminDeleteCategoriesRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminDeleteTags: async (
      adminDeleteCategoriesRequest: AdminDeleteCategoriesRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'adminDeleteCategoriesRequest' is not null or undefined
      assertParamExists(
        'adminDeleteTags',
        'adminDeleteCategoriesRequest',
        adminDeleteCategoriesRequest
      );
      const localVarPath = `/api/admin/tags/delete-tag`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication jwt required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        adminDeleteCategoriesRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Admin can delete user accounts including their own, but not other admins.
     * @summary Delete users by IDs
     * @param {AdminDeleteUsersRequest} adminDeleteUsersRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminDeleteUsers: async (
      adminDeleteUsersRequest: AdminDeleteUsersRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'adminDeleteUsersRequest' is not null or undefined
      assertParamExists(
        'adminDeleteUsers',
        'adminDeleteUsersRequest',
        adminDeleteUsersRequest
      );
      const localVarPath = `/api/admin/users/delete-user`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        adminDeleteUsersRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves articles from the database with pagination and optional search using request body parameters.
     * @summary Fetch articles with pagination and search
     * @param {AdminGetArticlesRequest} adminGetArticlesRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminGetArticles: async (
      adminGetArticlesRequest: AdminGetArticlesRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'adminGetArticlesRequest' is not null or undefined
      assertParamExists(
        'adminGetArticles',
        'adminGetArticlesRequest',
        adminGetArticlesRequest
      );
      const localVarPath = `/api/admin/articles/get-article`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication jwt required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        adminGetArticlesRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves categories from the database with pagination and optional search using query parameters.
     * @summary Fetch categories with pagination and search
     * @param {number} page The page number for pagination.
     * @param {number} limit The number of categories to return per page.
     * @param {string} [search] Optional search term to filter categories by name or description.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminGetCategories: async (
      page: number,
      limit: number,
      search?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'page' is not null or undefined
      assertParamExists('adminGetCategories', 'page', page);
      // verify required parameter 'limit' is not null or undefined
      assertParamExists('adminGetCategories', 'limit', limit);
      const localVarPath = `/api/admin/categories/get-category`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication jwt required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (search !== undefined) {
        localVarQueryParameter['search'] = search;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves contacts from the database with pagination and optional search using query parameters.
     * @summary Fetch contacts with pagination and search
     * @param {number} page The page number for pagination.
     * @param {number} limit The number of contacts to return per page.
     * @param {string} [search] Optional search term to filter contacts by company name, contact name, or email.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminGetContacts: async (
      page: number,
      limit: number,
      search?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'page' is not null or undefined
      assertParamExists('adminGetContacts', 'page', page);
      // verify required parameter 'limit' is not null or undefined
      assertParamExists('adminGetContacts', 'limit', limit);
      const localVarPath = `/api/admin/contacts/get-contact`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication jwt required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (search !== undefined) {
        localVarQueryParameter['search'] = search;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves tags from the database with pagination and optional search using query parameters.
     * @summary Fetch tags with pagination and search
     * @param {number} page The page number for pagination.
     * @param {number} limit The number of tags to return per page.
     * @param {string} [search] Optional search term to filter tags by name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminGetTags: async (
      page: number,
      limit: number,
      search?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'page' is not null or undefined
      assertParamExists('adminGetTags', 'page', page);
      // verify required parameter 'limit' is not null or undefined
      assertParamExists('adminGetTags', 'limit', limit);
      const localVarPath = `/api/admin/tags/get-tags`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication jwt required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (search !== undefined) {
        localVarQueryParameter['search'] = search;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves users from the database with pagination and optional search.
     * @summary Fetch users with pagination and search
     * @param {AdminGetUsersRequest} adminGetUsersRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminGetUsers: async (
      adminGetUsersRequest: AdminGetUsersRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'adminGetUsersRequest' is not null or undefined
      assertParamExists(
        'adminGetUsers',
        'adminGetUsersRequest',
        adminGetUsersRequest
      );
      const localVarPath = `/api/admin/users/get-user`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        adminGetUsersRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Updates details of an existing article based on the provided article ID. Tags will be created if they do not exist and linked to the article. All tag associations will be replaced.
     * @summary Update article details
     * @param {AdminUpdateArticleRequest} adminUpdateArticleRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminUpdateArticle: async (
      adminUpdateArticleRequest: AdminUpdateArticleRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'adminUpdateArticleRequest' is not null or undefined
      assertParamExists(
        'adminUpdateArticle',
        'adminUpdateArticleRequest',
        adminUpdateArticleRequest
      );
      const localVarPath = `/api/admin/articles/update-article`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication jwt required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        adminUpdateArticleRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Updates details of an existing category based on the provided category ID.
     * @summary Update category details
     * @param {AdminUpdateCategoryRequest} adminUpdateCategoryRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminUpdateCategory: async (
      adminUpdateCategoryRequest: AdminUpdateCategoryRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'adminUpdateCategoryRequest' is not null or undefined
      assertParamExists(
        'adminUpdateCategory',
        'adminUpdateCategoryRequest',
        adminUpdateCategoryRequest
      );
      const localVarPath = `/api/admin/categories/update-category`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication jwt required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        adminUpdateCategoryRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update only the status of a contact by ID.
     * @summary Update contact status
     * @param {AdminUpdateContactRequest} adminUpdateContactRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminUpdateContact: async (
      adminUpdateContactRequest: AdminUpdateContactRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'adminUpdateContactRequest' is not null or undefined
      assertParamExists(
        'adminUpdateContact',
        'adminUpdateContactRequest',
        adminUpdateContactRequest
      );
      const localVarPath = `/api/admin/contacts/update-contact`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication jwt required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        adminUpdateContactRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Updates details of an existing tag based on the provided tag ID.
     * @summary Update tag details
     * @param {AdminUpdateTagRequest} adminUpdateTagRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminUpdateTag: async (
      adminUpdateTagRequest: AdminUpdateTagRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'adminUpdateTagRequest' is not null or undefined
      assertParamExists(
        'adminUpdateTag',
        'adminUpdateTagRequest',
        adminUpdateTagRequest
      );
      const localVarPath = `/api/admin/tags/update-tag`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication jwt required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        adminUpdateTagRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update details of an existing user based on the provided user ID.
     * @summary Update user details
     * @param {AdminUpdateUserRequest} adminUpdateUserRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminUpdateUser: async (
      adminUpdateUserRequest: AdminUpdateUserRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'adminUpdateUserRequest' is not null or undefined
      assertParamExists(
        'adminUpdateUser',
        'adminUpdateUserRequest',
        adminUpdateUserRequest
      );
      const localVarPath = `/api/admin/users/update-user`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        adminUpdateUserRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AdminApi - functional programming interface
 * @export
 */
export const AdminApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration);
  return {
    /**
     * Creates a new article with a unique slug. Tags will be created if they do not exist and linked to the article. The first author in the database will be assigned.
     * @summary Create a new article
     * @param {AdminCreateArticleRequest} adminCreateArticleRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminCreateArticle(
      adminCreateArticleRequest: AdminCreateArticleRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<AdminCreateArticle201Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.adminCreateArticle(
          adminCreateArticleRequest,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.adminCreateArticle']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Creates a new category with a unique name and slug.
     * @summary Create a new category
     * @param {AdminCreateCategoryRequest} adminCreateCategoryRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminCreateCategory(
      adminCreateCategoryRequest: AdminCreateCategoryRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<AdminCreateCategory201Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.adminCreateCategory(
          adminCreateCategoryRequest,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.adminCreateCategory']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Creates a new tag with a unique name.
     * @summary Create a new tag
     * @param {AdminCreateTagRequest} adminCreateTagRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminCreateTag(
      adminCreateTagRequest: AdminCreateTagRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<AdminCreateTag201Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.adminCreateTag(
        adminCreateTagRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.adminCreateTag']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Creates a new user, hashes their password, generates an email verification token, and sends a verification email.
     * @summary Register a new user
     * @param {AdminCreateUserRequest} adminCreateUserRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminCreateUser(
      adminCreateUserRequest: AdminCreateUserRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Created>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.adminCreateUser(
        adminCreateUserRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.adminCreateUser']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Deletes articles by their IDs (soft delete, sets deletedAt). Also removes associated tags.
     * @summary Delete articles by IDs (soft delete)
     * @param {AdminDeleteArticlesRequest} adminDeleteArticlesRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminDeleteArticles(
      adminDeleteArticlesRequest: AdminDeleteArticlesRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<AdminDeleteArticles200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.adminDeleteArticles(
          adminDeleteArticlesRequest,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.adminDeleteArticles']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Deletes categories by their IDs (soft delete, sets deletedAt).
     * @summary Delete categories by IDs
     * @param {AdminDeleteCategoriesRequest} adminDeleteCategoriesRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminDeleteCategories(
      adminDeleteCategoriesRequest: AdminDeleteCategoriesRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.adminDeleteCategories(
          adminDeleteCategoriesRequest,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.adminDeleteCategories']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Deletes contacts by their IDs.
     * @summary Delete contacts by IDs
     * @param {AdminDeleteCategoriesRequest} adminDeleteCategoriesRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminDeleteContacts(
      adminDeleteCategoriesRequest: AdminDeleteCategoriesRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.adminDeleteContacts(
          adminDeleteCategoriesRequest,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.adminDeleteContacts']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Deletes tags by their IDs (soft delete, sets deletedAt).
     * @summary Delete tags by IDs
     * @param {AdminDeleteCategoriesRequest} adminDeleteCategoriesRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminDeleteTags(
      adminDeleteCategoriesRequest: AdminDeleteCategoriesRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.adminDeleteTags(
        adminDeleteCategoriesRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.adminDeleteTags']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Admin can delete user accounts including their own, but not other admins.
     * @summary Delete users by IDs
     * @param {AdminDeleteUsersRequest} adminDeleteUsersRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminDeleteUsers(
      adminDeleteUsersRequest: AdminDeleteUsersRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.adminDeleteUsers(
          adminDeleteUsersRequest,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.adminDeleteUsers']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Retrieves articles from the database with pagination and optional search using request body parameters.
     * @summary Fetch articles with pagination and search
     * @param {AdminGetArticlesRequest} adminGetArticlesRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminGetArticles(
      adminGetArticlesRequest: AdminGetArticlesRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<AdminGetArticles200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.adminGetArticles(
          adminGetArticlesRequest,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.adminGetArticles']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Retrieves categories from the database with pagination and optional search using query parameters.
     * @summary Fetch categories with pagination and search
     * @param {number} page The page number for pagination.
     * @param {number} limit The number of categories to return per page.
     * @param {string} [search] Optional search term to filter categories by name or description.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminGetCategories(
      page: number,
      limit: number,
      search?: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<AdminGetCategories200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.adminGetCategories(
          page,
          limit,
          search,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.adminGetCategories']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Retrieves contacts from the database with pagination and optional search using query parameters.
     * @summary Fetch contacts with pagination and search
     * @param {number} page The page number for pagination.
     * @param {number} limit The number of contacts to return per page.
     * @param {string} [search] Optional search term to filter contacts by company name, contact name, or email.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminGetContacts(
      page: number,
      limit: number,
      search?: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<AdminGetContacts200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.adminGetContacts(
          page,
          limit,
          search,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.adminGetContacts']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Retrieves tags from the database with pagination and optional search using query parameters.
     * @summary Fetch tags with pagination and search
     * @param {number} page The page number for pagination.
     * @param {number} limit The number of tags to return per page.
     * @param {string} [search] Optional search term to filter tags by name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminGetTags(
      page: number,
      limit: number,
      search?: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<AdminGetTags200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.adminGetTags(
        page,
        limit,
        search,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.adminGetTags']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Retrieves users from the database with pagination and optional search.
     * @summary Fetch users with pagination and search
     * @param {AdminGetUsersRequest} adminGetUsersRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminGetUsers(
      adminGetUsersRequest: AdminGetUsersRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<AdminGetUsers200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.adminGetUsers(
        adminGetUsersRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.adminGetUsers']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Updates details of an existing article based on the provided article ID. Tags will be created if they do not exist and linked to the article. All tag associations will be replaced.
     * @summary Update article details
     * @param {AdminUpdateArticleRequest} adminUpdateArticleRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminUpdateArticle(
      adminUpdateArticleRequest: AdminUpdateArticleRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<AdminUpdateArticle200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.adminUpdateArticle(
          adminUpdateArticleRequest,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.adminUpdateArticle']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Updates details of an existing category based on the provided category ID.
     * @summary Update category details
     * @param {AdminUpdateCategoryRequest} adminUpdateCategoryRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminUpdateCategory(
      adminUpdateCategoryRequest: AdminUpdateCategoryRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<AdminUpdateCategory200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.adminUpdateCategory(
          adminUpdateCategoryRequest,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.adminUpdateCategory']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Update only the status of a contact by ID.
     * @summary Update contact status
     * @param {AdminUpdateContactRequest} adminUpdateContactRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminUpdateContact(
      adminUpdateContactRequest: AdminUpdateContactRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<AdminUpdateContact200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.adminUpdateContact(
          adminUpdateContactRequest,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.adminUpdateContact']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Updates details of an existing tag based on the provided tag ID.
     * @summary Update tag details
     * @param {AdminUpdateTagRequest} adminUpdateTagRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminUpdateTag(
      adminUpdateTagRequest: AdminUpdateTagRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<AdminUpdateTag200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.adminUpdateTag(
        adminUpdateTagRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.adminUpdateTag']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Update details of an existing user based on the provided user ID.
     * @summary Update user details
     * @param {AdminUpdateUserRequest} adminUpdateUserRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminUpdateUser(
      adminUpdateUserRequest: AdminUpdateUserRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<AdminUpdateUser200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.adminUpdateUser(
        adminUpdateUserRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.adminUpdateUser']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * AdminApi - factory interface
 * @export
 */
export const AdminApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = AdminApiFp(configuration);
  return {
    /**
     * Creates a new article with a unique slug. Tags will be created if they do not exist and linked to the article. The first author in the database will be assigned.
     * @summary Create a new article
     * @param {AdminCreateArticleRequest} adminCreateArticleRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminCreateArticle(
      adminCreateArticleRequest: AdminCreateArticleRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<AdminCreateArticle201Response> {
      return localVarFp
        .adminCreateArticle(adminCreateArticleRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Creates a new category with a unique name and slug.
     * @summary Create a new category
     * @param {AdminCreateCategoryRequest} adminCreateCategoryRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminCreateCategory(
      adminCreateCategoryRequest: AdminCreateCategoryRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<AdminCreateCategory201Response> {
      return localVarFp
        .adminCreateCategory(adminCreateCategoryRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Creates a new tag with a unique name.
     * @summary Create a new tag
     * @param {AdminCreateTagRequest} adminCreateTagRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminCreateTag(
      adminCreateTagRequest: AdminCreateTagRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<AdminCreateTag201Response> {
      return localVarFp
        .adminCreateTag(adminCreateTagRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Creates a new user, hashes their password, generates an email verification token, and sends a verification email.
     * @summary Register a new user
     * @param {AdminCreateUserRequest} adminCreateUserRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminCreateUser(
      adminCreateUserRequest: AdminCreateUserRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Created> {
      return localVarFp
        .adminCreateUser(adminCreateUserRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Deletes articles by their IDs (soft delete, sets deletedAt). Also removes associated tags.
     * @summary Delete articles by IDs (soft delete)
     * @param {AdminDeleteArticlesRequest} adminDeleteArticlesRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminDeleteArticles(
      adminDeleteArticlesRequest: AdminDeleteArticlesRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<AdminDeleteArticles200Response> {
      return localVarFp
        .adminDeleteArticles(adminDeleteArticlesRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Deletes categories by their IDs (soft delete, sets deletedAt).
     * @summary Delete categories by IDs
     * @param {AdminDeleteCategoriesRequest} adminDeleteCategoriesRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminDeleteCategories(
      adminDeleteCategoriesRequest: AdminDeleteCategoriesRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Success> {
      return localVarFp
        .adminDeleteCategories(adminDeleteCategoriesRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Deletes contacts by their IDs.
     * @summary Delete contacts by IDs
     * @param {AdminDeleteCategoriesRequest} adminDeleteCategoriesRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminDeleteContacts(
      adminDeleteCategoriesRequest: AdminDeleteCategoriesRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Success> {
      return localVarFp
        .adminDeleteContacts(adminDeleteCategoriesRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Deletes tags by their IDs (soft delete, sets deletedAt).
     * @summary Delete tags by IDs
     * @param {AdminDeleteCategoriesRequest} adminDeleteCategoriesRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminDeleteTags(
      adminDeleteCategoriesRequest: AdminDeleteCategoriesRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Success> {
      return localVarFp
        .adminDeleteTags(adminDeleteCategoriesRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Admin can delete user accounts including their own, but not other admins.
     * @summary Delete users by IDs
     * @param {AdminDeleteUsersRequest} adminDeleteUsersRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminDeleteUsers(
      adminDeleteUsersRequest: AdminDeleteUsersRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Success> {
      return localVarFp
        .adminDeleteUsers(adminDeleteUsersRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves articles from the database with pagination and optional search using request body parameters.
     * @summary Fetch articles with pagination and search
     * @param {AdminGetArticlesRequest} adminGetArticlesRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminGetArticles(
      adminGetArticlesRequest: AdminGetArticlesRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<AdminGetArticles200Response> {
      return localVarFp
        .adminGetArticles(adminGetArticlesRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves categories from the database with pagination and optional search using query parameters.
     * @summary Fetch categories with pagination and search
     * @param {number} page The page number for pagination.
     * @param {number} limit The number of categories to return per page.
     * @param {string} [search] Optional search term to filter categories by name or description.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminGetCategories(
      page: number,
      limit: number,
      search?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<AdminGetCategories200Response> {
      return localVarFp
        .adminGetCategories(page, limit, search, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves contacts from the database with pagination and optional search using query parameters.
     * @summary Fetch contacts with pagination and search
     * @param {number} page The page number for pagination.
     * @param {number} limit The number of contacts to return per page.
     * @param {string} [search] Optional search term to filter contacts by company name, contact name, or email.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminGetContacts(
      page: number,
      limit: number,
      search?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<AdminGetContacts200Response> {
      return localVarFp
        .adminGetContacts(page, limit, search, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves tags from the database with pagination and optional search using query parameters.
     * @summary Fetch tags with pagination and search
     * @param {number} page The page number for pagination.
     * @param {number} limit The number of tags to return per page.
     * @param {string} [search] Optional search term to filter tags by name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminGetTags(
      page: number,
      limit: number,
      search?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<AdminGetTags200Response> {
      return localVarFp
        .adminGetTags(page, limit, search, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves users from the database with pagination and optional search.
     * @summary Fetch users with pagination and search
     * @param {AdminGetUsersRequest} adminGetUsersRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminGetUsers(
      adminGetUsersRequest: AdminGetUsersRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<AdminGetUsers200Response> {
      return localVarFp
        .adminGetUsers(adminGetUsersRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Updates details of an existing article based on the provided article ID. Tags will be created if they do not exist and linked to the article. All tag associations will be replaced.
     * @summary Update article details
     * @param {AdminUpdateArticleRequest} adminUpdateArticleRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminUpdateArticle(
      adminUpdateArticleRequest: AdminUpdateArticleRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<AdminUpdateArticle200Response> {
      return localVarFp
        .adminUpdateArticle(adminUpdateArticleRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Updates details of an existing category based on the provided category ID.
     * @summary Update category details
     * @param {AdminUpdateCategoryRequest} adminUpdateCategoryRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminUpdateCategory(
      adminUpdateCategoryRequest: AdminUpdateCategoryRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<AdminUpdateCategory200Response> {
      return localVarFp
        .adminUpdateCategory(adminUpdateCategoryRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Update only the status of a contact by ID.
     * @summary Update contact status
     * @param {AdminUpdateContactRequest} adminUpdateContactRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminUpdateContact(
      adminUpdateContactRequest: AdminUpdateContactRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<AdminUpdateContact200Response> {
      return localVarFp
        .adminUpdateContact(adminUpdateContactRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Updates details of an existing tag based on the provided tag ID.
     * @summary Update tag details
     * @param {AdminUpdateTagRequest} adminUpdateTagRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminUpdateTag(
      adminUpdateTagRequest: AdminUpdateTagRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<AdminUpdateTag200Response> {
      return localVarFp
        .adminUpdateTag(adminUpdateTagRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Update details of an existing user based on the provided user ID.
     * @summary Update user details
     * @param {AdminUpdateUserRequest} adminUpdateUserRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminUpdateUser(
      adminUpdateUserRequest: AdminUpdateUserRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<AdminUpdateUser200Response> {
      return localVarFp
        .adminUpdateUser(adminUpdateUserRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */
export class AdminApi extends BaseAPI {
  /**
   * Creates a new article with a unique slug. Tags will be created if they do not exist and linked to the article. The first author in the database will be assigned.
   * @summary Create a new article
   * @param {AdminCreateArticleRequest} adminCreateArticleRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public adminCreateArticle(
    adminCreateArticleRequest: AdminCreateArticleRequest,
    options?: RawAxiosRequestConfig
  ) {
    return AdminApiFp(this.configuration)
      .adminCreateArticle(adminCreateArticleRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Creates a new category with a unique name and slug.
   * @summary Create a new category
   * @param {AdminCreateCategoryRequest} adminCreateCategoryRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public adminCreateCategory(
    adminCreateCategoryRequest: AdminCreateCategoryRequest,
    options?: RawAxiosRequestConfig
  ) {
    return AdminApiFp(this.configuration)
      .adminCreateCategory(adminCreateCategoryRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Creates a new tag with a unique name.
   * @summary Create a new tag
   * @param {AdminCreateTagRequest} adminCreateTagRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public adminCreateTag(
    adminCreateTagRequest: AdminCreateTagRequest,
    options?: RawAxiosRequestConfig
  ) {
    return AdminApiFp(this.configuration)
      .adminCreateTag(adminCreateTagRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Creates a new user, hashes their password, generates an email verification token, and sends a verification email.
   * @summary Register a new user
   * @param {AdminCreateUserRequest} adminCreateUserRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public adminCreateUser(
    adminCreateUserRequest: AdminCreateUserRequest,
    options?: RawAxiosRequestConfig
  ) {
    return AdminApiFp(this.configuration)
      .adminCreateUser(adminCreateUserRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Deletes articles by their IDs (soft delete, sets deletedAt). Also removes associated tags.
   * @summary Delete articles by IDs (soft delete)
   * @param {AdminDeleteArticlesRequest} adminDeleteArticlesRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public adminDeleteArticles(
    adminDeleteArticlesRequest: AdminDeleteArticlesRequest,
    options?: RawAxiosRequestConfig
  ) {
    return AdminApiFp(this.configuration)
      .adminDeleteArticles(adminDeleteArticlesRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Deletes categories by their IDs (soft delete, sets deletedAt).
   * @summary Delete categories by IDs
   * @param {AdminDeleteCategoriesRequest} adminDeleteCategoriesRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public adminDeleteCategories(
    adminDeleteCategoriesRequest: AdminDeleteCategoriesRequest,
    options?: RawAxiosRequestConfig
  ) {
    return AdminApiFp(this.configuration)
      .adminDeleteCategories(adminDeleteCategoriesRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Deletes contacts by their IDs.
   * @summary Delete contacts by IDs
   * @param {AdminDeleteCategoriesRequest} adminDeleteCategoriesRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public adminDeleteContacts(
    adminDeleteCategoriesRequest: AdminDeleteCategoriesRequest,
    options?: RawAxiosRequestConfig
  ) {
    return AdminApiFp(this.configuration)
      .adminDeleteContacts(adminDeleteCategoriesRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Deletes tags by their IDs (soft delete, sets deletedAt).
   * @summary Delete tags by IDs
   * @param {AdminDeleteCategoriesRequest} adminDeleteCategoriesRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public adminDeleteTags(
    adminDeleteCategoriesRequest: AdminDeleteCategoriesRequest,
    options?: RawAxiosRequestConfig
  ) {
    return AdminApiFp(this.configuration)
      .adminDeleteTags(adminDeleteCategoriesRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Admin can delete user accounts including their own, but not other admins.
   * @summary Delete users by IDs
   * @param {AdminDeleteUsersRequest} adminDeleteUsersRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public adminDeleteUsers(
    adminDeleteUsersRequest: AdminDeleteUsersRequest,
    options?: RawAxiosRequestConfig
  ) {
    return AdminApiFp(this.configuration)
      .adminDeleteUsers(adminDeleteUsersRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieves articles from the database with pagination and optional search using request body parameters.
   * @summary Fetch articles with pagination and search
   * @param {AdminGetArticlesRequest} adminGetArticlesRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public adminGetArticles(
    adminGetArticlesRequest: AdminGetArticlesRequest,
    options?: RawAxiosRequestConfig
  ) {
    return AdminApiFp(this.configuration)
      .adminGetArticles(adminGetArticlesRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieves categories from the database with pagination and optional search using query parameters.
   * @summary Fetch categories with pagination and search
   * @param {number} page The page number for pagination.
   * @param {number} limit The number of categories to return per page.
   * @param {string} [search] Optional search term to filter categories by name or description.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public adminGetCategories(
    page: number,
    limit: number,
    search?: string,
    options?: RawAxiosRequestConfig
  ) {
    return AdminApiFp(this.configuration)
      .adminGetCategories(page, limit, search, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieves contacts from the database with pagination and optional search using query parameters.
   * @summary Fetch contacts with pagination and search
   * @param {number} page The page number for pagination.
   * @param {number} limit The number of contacts to return per page.
   * @param {string} [search] Optional search term to filter contacts by company name, contact name, or email.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public adminGetContacts(
    page: number,
    limit: number,
    search?: string,
    options?: RawAxiosRequestConfig
  ) {
    return AdminApiFp(this.configuration)
      .adminGetContacts(page, limit, search, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieves tags from the database with pagination and optional search using query parameters.
   * @summary Fetch tags with pagination and search
   * @param {number} page The page number for pagination.
   * @param {number} limit The number of tags to return per page.
   * @param {string} [search] Optional search term to filter tags by name.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public adminGetTags(
    page: number,
    limit: number,
    search?: string,
    options?: RawAxiosRequestConfig
  ) {
    return AdminApiFp(this.configuration)
      .adminGetTags(page, limit, search, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieves users from the database with pagination and optional search.
   * @summary Fetch users with pagination and search
   * @param {AdminGetUsersRequest} adminGetUsersRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public adminGetUsers(
    adminGetUsersRequest: AdminGetUsersRequest,
    options?: RawAxiosRequestConfig
  ) {
    return AdminApiFp(this.configuration)
      .adminGetUsers(adminGetUsersRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Updates details of an existing article based on the provided article ID. Tags will be created if they do not exist and linked to the article. All tag associations will be replaced.
   * @summary Update article details
   * @param {AdminUpdateArticleRequest} adminUpdateArticleRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public adminUpdateArticle(
    adminUpdateArticleRequest: AdminUpdateArticleRequest,
    options?: RawAxiosRequestConfig
  ) {
    return AdminApiFp(this.configuration)
      .adminUpdateArticle(adminUpdateArticleRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Updates details of an existing category based on the provided category ID.
   * @summary Update category details
   * @param {AdminUpdateCategoryRequest} adminUpdateCategoryRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public adminUpdateCategory(
    adminUpdateCategoryRequest: AdminUpdateCategoryRequest,
    options?: RawAxiosRequestConfig
  ) {
    return AdminApiFp(this.configuration)
      .adminUpdateCategory(adminUpdateCategoryRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update only the status of a contact by ID.
   * @summary Update contact status
   * @param {AdminUpdateContactRequest} adminUpdateContactRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public adminUpdateContact(
    adminUpdateContactRequest: AdminUpdateContactRequest,
    options?: RawAxiosRequestConfig
  ) {
    return AdminApiFp(this.configuration)
      .adminUpdateContact(adminUpdateContactRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Updates details of an existing tag based on the provided tag ID.
   * @summary Update tag details
   * @param {AdminUpdateTagRequest} adminUpdateTagRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public adminUpdateTag(
    adminUpdateTagRequest: AdminUpdateTagRequest,
    options?: RawAxiosRequestConfig
  ) {
    return AdminApiFp(this.configuration)
      .adminUpdateTag(adminUpdateTagRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update details of an existing user based on the provided user ID.
   * @summary Update user details
   * @param {AdminUpdateUserRequest} adminUpdateUserRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public adminUpdateUser(
    adminUpdateUserRequest: AdminUpdateUserRequest,
    options?: RawAxiosRequestConfig
  ) {
    return AdminApiFp(this.configuration)
      .adminUpdateUser(adminUpdateUserRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ArticlesApi - axios parameter creator
 * @export
 */
export const ArticlesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Retrieves articles from the database with pagination using skip and take query parameters, optionally filtered by category.
     * @summary Fetch articles with pagination
     * @param {number} skip The number of articles to skip for pagination.
     * @param {number} take The number of articles to return per request.
     * @param {string} [category] The name of the category to filter articles by (optional).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArticles: async (
      skip: number,
      take: number,
      category?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'skip' is not null or undefined
      assertParamExists('getArticles', 'skip', skip);
      // verify required parameter 'take' is not null or undefined
      assertParamExists('getArticles', 'take', take);
      const localVarPath = `/api/articles`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (skip !== undefined) {
        localVarQueryParameter['skip'] = skip;
      }

      if (take !== undefined) {
        localVarQueryParameter['take'] = take;
      }

      if (category !== undefined) {
        localVarQueryParameter['category'] = category;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Increments the view count for an article and returns the updated count.
     * @summary Increment article view count
     * @param {string} id ID of the article to view.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    incrementArticleViewCount: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('incrementArticleViewCount', 'id', id);
      const localVarPath = `/api/articles/{id}/view`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ArticlesApi - functional programming interface
 * @export
 */
export const ArticlesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ArticlesApiAxiosParamCreator(configuration);
  return {
    /**
     * Retrieves articles from the database with pagination using skip and take query parameters, optionally filtered by category.
     * @summary Fetch articles with pagination
     * @param {number} skip The number of articles to skip for pagination.
     * @param {number} take The number of articles to return per request.
     * @param {string} [category] The name of the category to filter articles by (optional).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getArticles(
      skip: number,
      take: number,
      category?: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetArticles200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getArticles(
        skip,
        take,
        category,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ArticlesApi.getArticles']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Increments the view count for an article and returns the updated count.
     * @summary Increment article view count
     * @param {string} id ID of the article to view.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async incrementArticleViewCount(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<IncrementArticleViewCount200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.incrementArticleViewCount(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ArticlesApi.incrementArticleViewCount']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ArticlesApi - factory interface
 * @export
 */
export const ArticlesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ArticlesApiFp(configuration);
  return {
    /**
     * Retrieves articles from the database with pagination using skip and take query parameters, optionally filtered by category.
     * @summary Fetch articles with pagination
     * @param {number} skip The number of articles to skip for pagination.
     * @param {number} take The number of articles to return per request.
     * @param {string} [category] The name of the category to filter articles by (optional).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArticles(
      skip: number,
      take: number,
      category?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<GetArticles200Response> {
      return localVarFp
        .getArticles(skip, take, category, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Increments the view count for an article and returns the updated count.
     * @summary Increment article view count
     * @param {string} id ID of the article to view.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    incrementArticleViewCount(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<IncrementArticleViewCount200Response> {
      return localVarFp
        .incrementArticleViewCount(id, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ArticlesApi - object-oriented interface
 * @export
 * @class ArticlesApi
 * @extends {BaseAPI}
 */
export class ArticlesApi extends BaseAPI {
  /**
   * Retrieves articles from the database with pagination using skip and take query parameters, optionally filtered by category.
   * @summary Fetch articles with pagination
   * @param {number} skip The number of articles to skip for pagination.
   * @param {number} take The number of articles to return per request.
   * @param {string} [category] The name of the category to filter articles by (optional).
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ArticlesApi
   */
  public getArticles(
    skip: number,
    take: number,
    category?: string,
    options?: RawAxiosRequestConfig
  ) {
    return ArticlesApiFp(this.configuration)
      .getArticles(skip, take, category, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Increments the view count for an article and returns the updated count.
   * @summary Increment article view count
   * @param {string} id ID of the article to view.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ArticlesApi
   */
  public incrementArticleViewCount(
    id: string,
    options?: RawAxiosRequestConfig
  ) {
    return ArticlesApiFp(this.configuration)
      .incrementArticleViewCount(id, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Allows an authenticated user to change their password by providing the old and new password.
     * @summary Change user password
     * @param {ChangePasswordRequest} changePasswordRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changePassword: async (
      changePasswordRequest: ChangePasswordRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'changePasswordRequest' is not null or undefined
      assertParamExists(
        'changePassword',
        'changePasswordRequest',
        changePasswordRequest
      );
      const localVarPath = `/api/auth/change-password`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        changePasswordRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Sends a reset password email with a secure token link. Each user is allowed a maximum of 3 emails per hour.
     * @summary Send a password reset email
     * @param {ForgetPasswordRequest} forgetPasswordRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    forgetPassword: async (
      forgetPasswordRequest: ForgetPasswordRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'forgetPasswordRequest' is not null or undefined
      assertParamExists(
        'forgetPassword',
        'forgetPasswordRequest',
        forgetPasswordRequest
      );
      const localVarPath = `/api/auth/forget-password`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        forgetPasswordRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Creates a new user, hashes their password, generates an email verification token, and sends a verification email.
     * @summary Register a new user
     * @param {RegisterRequest} registerRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    register: async (
      registerRequest: RegisterRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'registerRequest' is not null or undefined
      assertParamExists('register', 'registerRequest', registerRequest);
      const localVarPath = `/api/auth/register`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        registerRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Resets the user\'s password using a provided reset token and new password. The reset token is invalidated after the reset.
     * @summary Reset password for a user
     * @param {ResetPasswordRequest} resetPasswordRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetPassword: async (
      resetPasswordRequest: ResetPasswordRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'resetPasswordRequest' is not null or undefined
      assertParamExists(
        'resetPassword',
        'resetPasswordRequest',
        resetPasswordRequest
      );
      const localVarPath = `/api/reset-password`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        resetPasswordRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint sends a verification email to the user with the provided email address.
     * @summary Send verification email to a registered user
     * @param {ForgetPasswordRequest} forgetPasswordRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendVerificationEmail: async (
      forgetPasswordRequest: ForgetPasswordRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'forgetPasswordRequest' is not null or undefined
      assertParamExists(
        'sendVerificationEmail',
        'forgetPasswordRequest',
        forgetPasswordRequest
      );
      const localVarPath = `/api/auth/verify-email-request`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        forgetPasswordRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Verifies the user\'s email address using a provided verification token. Marks the user\'s email as verified in the database.
     * @summary Verify user email
     * @param {string} token The email verification token sent to the user\&#39;s email address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyEmail: async (
      token: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'token' is not null or undefined
      assertParamExists('verifyEmail', 'token', token);
      const localVarPath = `/api/auth/verify-email`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (token !== undefined) {
        localVarQueryParameter['token'] = token;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration);
  return {
    /**
     * Allows an authenticated user to change their password by providing the old and new password.
     * @summary Change user password
     * @param {ChangePasswordRequest} changePasswordRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async changePassword(
      changePasswordRequest: ChangePasswordRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.changePassword(
        changePasswordRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AuthApi.changePassword']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Sends a reset password email with a secure token link. Each user is allowed a maximum of 3 emails per hour.
     * @summary Send a password reset email
     * @param {ForgetPasswordRequest} forgetPasswordRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async forgetPassword(
      forgetPasswordRequest: ForgetPasswordRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.forgetPassword(
        forgetPasswordRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AuthApi.forgetPassword']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Creates a new user, hashes their password, generates an email verification token, and sends a verification email.
     * @summary Register a new user
     * @param {RegisterRequest} registerRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async register(
      registerRequest: RegisterRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Created>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.register(
        registerRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AuthApi.register']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Resets the user\'s password using a provided reset token and new password. The reset token is invalidated after the reset.
     * @summary Reset password for a user
     * @param {ResetPasswordRequest} resetPasswordRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async resetPassword(
      resetPasswordRequest: ResetPasswordRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.resetPassword(
        resetPasswordRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AuthApi.resetPassword']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * This endpoint sends a verification email to the user with the provided email address.
     * @summary Send verification email to a registered user
     * @param {ForgetPasswordRequest} forgetPasswordRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sendVerificationEmail(
      forgetPasswordRequest: ForgetPasswordRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.sendVerificationEmail(
          forgetPasswordRequest,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AuthApi.sendVerificationEmail']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Verifies the user\'s email address using a provided verification token. Marks the user\'s email as verified in the database.
     * @summary Verify user email
     * @param {string} token The email verification token sent to the user\&#39;s email address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async verifyEmail(
      token: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.verifyEmail(
        token,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AuthApi.verifyEmail']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = AuthApiFp(configuration);
  return {
    /**
     * Allows an authenticated user to change their password by providing the old and new password.
     * @summary Change user password
     * @param {ChangePasswordRequest} changePasswordRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changePassword(
      changePasswordRequest: ChangePasswordRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Success> {
      return localVarFp
        .changePassword(changePasswordRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Sends a reset password email with a secure token link. Each user is allowed a maximum of 3 emails per hour.
     * @summary Send a password reset email
     * @param {ForgetPasswordRequest} forgetPasswordRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    forgetPassword(
      forgetPasswordRequest: ForgetPasswordRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Success> {
      return localVarFp
        .forgetPassword(forgetPasswordRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Creates a new user, hashes their password, generates an email verification token, and sends a verification email.
     * @summary Register a new user
     * @param {RegisterRequest} registerRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    register(
      registerRequest: RegisterRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Created> {
      return localVarFp
        .register(registerRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Resets the user\'s password using a provided reset token and new password. The reset token is invalidated after the reset.
     * @summary Reset password for a user
     * @param {ResetPasswordRequest} resetPasswordRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetPassword(
      resetPasswordRequest: ResetPasswordRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Success> {
      return localVarFp
        .resetPassword(resetPasswordRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * This endpoint sends a verification email to the user with the provided email address.
     * @summary Send verification email to a registered user
     * @param {ForgetPasswordRequest} forgetPasswordRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendVerificationEmail(
      forgetPasswordRequest: ForgetPasswordRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Success> {
      return localVarFp
        .sendVerificationEmail(forgetPasswordRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Verifies the user\'s email address using a provided verification token. Marks the user\'s email as verified in the database.
     * @summary Verify user email
     * @param {string} token The email verification token sent to the user\&#39;s email address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyEmail(
      token: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Success> {
      return localVarFp
        .verifyEmail(token, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
  /**
   * Allows an authenticated user to change their password by providing the old and new password.
   * @summary Change user password
   * @param {ChangePasswordRequest} changePasswordRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public changePassword(
    changePasswordRequest: ChangePasswordRequest,
    options?: RawAxiosRequestConfig
  ) {
    return AuthApiFp(this.configuration)
      .changePassword(changePasswordRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Sends a reset password email with a secure token link. Each user is allowed a maximum of 3 emails per hour.
   * @summary Send a password reset email
   * @param {ForgetPasswordRequest} forgetPasswordRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public forgetPassword(
    forgetPasswordRequest: ForgetPasswordRequest,
    options?: RawAxiosRequestConfig
  ) {
    return AuthApiFp(this.configuration)
      .forgetPassword(forgetPasswordRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Creates a new user, hashes their password, generates an email verification token, and sends a verification email.
   * @summary Register a new user
   * @param {RegisterRequest} registerRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public register(
    registerRequest: RegisterRequest,
    options?: RawAxiosRequestConfig
  ) {
    return AuthApiFp(this.configuration)
      .register(registerRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Resets the user\'s password using a provided reset token and new password. The reset token is invalidated after the reset.
   * @summary Reset password for a user
   * @param {ResetPasswordRequest} resetPasswordRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public resetPassword(
    resetPasswordRequest: ResetPasswordRequest,
    options?: RawAxiosRequestConfig
  ) {
    return AuthApiFp(this.configuration)
      .resetPassword(resetPasswordRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * This endpoint sends a verification email to the user with the provided email address.
   * @summary Send verification email to a registered user
   * @param {ForgetPasswordRequest} forgetPasswordRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public sendVerificationEmail(
    forgetPasswordRequest: ForgetPasswordRequest,
    options?: RawAxiosRequestConfig
  ) {
    return AuthApiFp(this.configuration)
      .sendVerificationEmail(forgetPasswordRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Verifies the user\'s email address using a provided verification token. Marks the user\'s email as verified in the database.
   * @summary Verify user email
   * @param {string} token The email verification token sent to the user\&#39;s email address.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public verifyEmail(token: string, options?: RawAxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .verifyEmail(token, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * CategoriesApi - axios parameter creator
 * @export
 */
export const CategoriesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Retrieves categories from the database with pagination using skip and take query parameters.
     * @summary Fetch categories with pagination
     * @param {number} skip The number of categories to skip for pagination.
     * @param {number} take The number of categories to return per request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCategories: async (
      skip: number,
      take: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'skip' is not null or undefined
      assertParamExists('getCategories', 'skip', skip);
      // verify required parameter 'take' is not null or undefined
      assertParamExists('getCategories', 'take', take);
      const localVarPath = `/api/categories`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (skip !== undefined) {
        localVarQueryParameter['skip'] = skip;
      }

      if (take !== undefined) {
        localVarQueryParameter['take'] = take;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CategoriesApi - functional programming interface
 * @export
 */
export const CategoriesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    CategoriesApiAxiosParamCreator(configuration);
  return {
    /**
     * Retrieves categories from the database with pagination using skip and take query parameters.
     * @summary Fetch categories with pagination
     * @param {number} skip The number of categories to skip for pagination.
     * @param {number} take The number of categories to return per request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCategories(
      skip: number,
      take: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetCategories200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getCategories(
        skip,
        take,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['CategoriesApi.getCategories']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * CategoriesApi - factory interface
 * @export
 */
export const CategoriesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = CategoriesApiFp(configuration);
  return {
    /**
     * Retrieves categories from the database with pagination using skip and take query parameters.
     * @summary Fetch categories with pagination
     * @param {number} skip The number of categories to skip for pagination.
     * @param {number} take The number of categories to return per request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCategories(
      skip: number,
      take: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<GetCategories200Response> {
      return localVarFp
        .getCategories(skip, take, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * CategoriesApi - object-oriented interface
 * @export
 * @class CategoriesApi
 * @extends {BaseAPI}
 */
export class CategoriesApi extends BaseAPI {
  /**
   * Retrieves categories from the database with pagination using skip and take query parameters.
   * @summary Fetch categories with pagination
   * @param {number} skip The number of categories to skip for pagination.
   * @param {number} take The number of categories to return per request.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CategoriesApi
   */
  public getCategories(
    skip: number,
    take: number,
    options?: RawAxiosRequestConfig
  ) {
    return CategoriesApiFp(this.configuration)
      .getCategories(skip, take, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ContactApi - axios parameter creator
 * @export
 */
export const ContactApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Submits a contact form with company details, contact information, and inquiry content. Stores the submission in the database and optionally sends a confirmation email.
     * @summary Submit a contact form inquiry
     * @param {SubmitContactFormRequest} submitContactFormRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitContactForm: async (
      submitContactFormRequest: SubmitContactFormRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'submitContactFormRequest' is not null or undefined
      assertParamExists(
        'submitContactForm',
        'submitContactFormRequest',
        submitContactFormRequest
      );
      const localVarPath = `/api/contact`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        submitContactFormRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ContactApi - functional programming interface
 * @export
 */
export const ContactApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ContactApiAxiosParamCreator(configuration);
  return {
    /**
     * Submits a contact form with company details, contact information, and inquiry content. Stores the submission in the database and optionally sends a confirmation email.
     * @summary Submit a contact form inquiry
     * @param {SubmitContactFormRequest} submitContactFormRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async submitContactForm(
      submitContactFormRequest: SubmitContactFormRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Created>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.submitContactForm(
          submitContactFormRequest,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ContactApi.submitContactForm']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ContactApi - factory interface
 * @export
 */
export const ContactApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ContactApiFp(configuration);
  return {
    /**
     * Submits a contact form with company details, contact information, and inquiry content. Stores the submission in the database and optionally sends a confirmation email.
     * @summary Submit a contact form inquiry
     * @param {SubmitContactFormRequest} submitContactFormRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitContactForm(
      submitContactFormRequest: SubmitContactFormRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Created> {
      return localVarFp
        .submitContactForm(submitContactFormRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ContactApi - object-oriented interface
 * @export
 * @class ContactApi
 * @extends {BaseAPI}
 */
export class ContactApi extends BaseAPI {
  /**
   * Submits a contact form with company details, contact information, and inquiry content. Stores the submission in the database and optionally sends a confirmation email.
   * @summary Submit a contact form inquiry
   * @param {SubmitContactFormRequest} submitContactFormRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContactApi
   */
  public submitContactForm(
    submitContactFormRequest: SubmitContactFormRequest,
    options?: RawAxiosRequestConfig
  ) {
    return ContactApiFp(this.configuration)
      .submitContactForm(submitContactFormRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
