/* tslint:disable */
/* eslint-disable */
/**
 * Next.js API
 * API documentation for Next.js 15 application
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AdminCreateCategory201Response
 */
export interface AdminCreateCategory201Response {
    /**
     * 
     * @type {string}
     * @memberof AdminCreateCategory201Response
     */
    'message'?: string;
    /**
     * 
     * @type {AdminCreateCategory201ResponseCategory}
     * @memberof AdminCreateCategory201Response
     */
    'category'?: AdminCreateCategory201ResponseCategory;
}
/**
 * 
 * @export
 * @interface AdminCreateCategory201ResponseCategory
 */
export interface AdminCreateCategory201ResponseCategory {
    /**
     * The unique identifier for the category.
     * @type {number}
     * @memberof AdminCreateCategory201ResponseCategory
     */
    'id'?: number;
    /**
     * The name of the category.
     * @type {string}
     * @memberof AdminCreateCategory201ResponseCategory
     */
    'name'?: string;
    /**
     * The unique slug for the category.
     * @type {string}
     * @memberof AdminCreateCategory201ResponseCategory
     */
    'slug'?: string;
    /**
     * The description of the category (optional).
     * @type {string}
     * @memberof AdminCreateCategory201ResponseCategory
     */
    'description'?: string | null;
    /**
     * The date and time when the category was created.
     * @type {string}
     * @memberof AdminCreateCategory201ResponseCategory
     */
    'createdAt'?: string;
    /**
     * The date and time when the category was last updated.
     * @type {string}
     * @memberof AdminCreateCategory201ResponseCategory
     */
    'updatedAt'?: string;
    /**
     * The date and time when the category was deleted (optional).
     * @type {string}
     * @memberof AdminCreateCategory201ResponseCategory
     */
    'deletedAt'?: string | null;
}
/**
 * 
 * @export
 * @interface AdminCreateCategory400Response
 */
export interface AdminCreateCategory400Response {
    /**
     * 
     * @type {string}
     * @memberof AdminCreateCategory400Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface AdminCreateCategoryRequest
 */
export interface AdminCreateCategoryRequest {
    /**
     * The name of the category.
     * @type {string}
     * @memberof AdminCreateCategoryRequest
     */
    'name': string;
    /**
     * The unique slug for the category.
     * @type {string}
     * @memberof AdminCreateCategoryRequest
     */
    'slug': string;
    /**
     * The description of the category (optional).
     * @type {string}
     * @memberof AdminCreateCategoryRequest
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface AdminCreateTag201Response
 */
export interface AdminCreateTag201Response {
    /**
     * 
     * @type {string}
     * @memberof AdminCreateTag201Response
     */
    'message'?: string;
    /**
     * 
     * @type {AdminCreateTag201ResponseTag}
     * @memberof AdminCreateTag201Response
     */
    'tag'?: AdminCreateTag201ResponseTag;
}
/**
 * 
 * @export
 * @interface AdminCreateTag201ResponseTag
 */
export interface AdminCreateTag201ResponseTag {
    /**
     * The unique identifier for the tag.
     * @type {number}
     * @memberof AdminCreateTag201ResponseTag
     */
    'id'?: number;
    /**
     * The name of the tag.
     * @type {string}
     * @memberof AdminCreateTag201ResponseTag
     */
    'name'?: string;
    /**
     * The date and time when the tag was created.
     * @type {string}
     * @memberof AdminCreateTag201ResponseTag
     */
    'createdAt'?: string;
    /**
     * The date and time when the tag was last updated.
     * @type {string}
     * @memberof AdminCreateTag201ResponseTag
     */
    'updatedAt'?: string;
    /**
     * The date and time when the tag was deleted (optional).
     * @type {string}
     * @memberof AdminCreateTag201ResponseTag
     */
    'deletedAt'?: string | null;
}
/**
 * 
 * @export
 * @interface AdminCreateTag400Response
 */
export interface AdminCreateTag400Response {
    /**
     * 
     * @type {string}
     * @memberof AdminCreateTag400Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface AdminCreateTagRequest
 */
export interface AdminCreateTagRequest {
    /**
     * The unique name of the tag.
     * @type {string}
     * @memberof AdminCreateTagRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface AdminCreateUser400Response
 */
export interface AdminCreateUser400Response {
    /**
     * 
     * @type {string}
     * @memberof AdminCreateUser400Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface AdminCreateUserRequest
 */
export interface AdminCreateUserRequest {
    /**
     * 
     * @type {string}
     * @memberof AdminCreateUserRequest
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof AdminCreateUserRequest
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof AdminCreateUserRequest
     */
    'country': string;
    /**
     * 
     * @type {string}
     * @memberof AdminCreateUserRequest
     */
    'gender'?: AdminCreateUserRequestGenderEnum;
    /**
     * 
     * @type {string}
     * @memberof AdminCreateUserRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof AdminCreateUserRequest
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof AdminCreateUserRequest
     */
    'phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminCreateUserRequest
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminCreateUserRequest
     */
    'role'?: string;
}

export const AdminCreateUserRequestGenderEnum = {
    Male: 'male',
    Female: 'female',
    Other: 'other'
} as const;

export type AdminCreateUserRequestGenderEnum = typeof AdminCreateUserRequestGenderEnum[keyof typeof AdminCreateUserRequestGenderEnum];

/**
 * 
 * @export
 * @interface AdminDeleteCategoriesRequest
 */
export interface AdminDeleteCategoriesRequest {
    /**
     * 
     * @type {Array<number>}
     * @memberof AdminDeleteCategoriesRequest
     */
    'ids': Array<number>;
}
/**
 * 
 * @export
 * @interface AdminDeleteUsersRequest
 */
export interface AdminDeleteUsersRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof AdminDeleteUsersRequest
     */
    'ids': Array<string>;
}
/**
 * 
 * @export
 * @interface AdminGetCategories200Response
 */
export interface AdminGetCategories200Response {
    /**
     * 
     * @type {Array<AdminGetCategories200ResponseDataInner>}
     * @memberof AdminGetCategories200Response
     */
    'data'?: Array<AdminGetCategories200ResponseDataInner>;
    /**
     * 
     * @type {AdminGetCategories200ResponsePagination}
     * @memberof AdminGetCategories200Response
     */
    'pagination'?: AdminGetCategories200ResponsePagination;
}
/**
 * 
 * @export
 * @interface AdminGetCategories200ResponseDataInner
 */
export interface AdminGetCategories200ResponseDataInner {
    /**
     * The unique identifier for the category.
     * @type {number}
     * @memberof AdminGetCategories200ResponseDataInner
     */
    'id'?: number;
    /**
     * The name of the category.
     * @type {string}
     * @memberof AdminGetCategories200ResponseDataInner
     */
    'name'?: string;
    /**
     * The unique slug for the category.
     * @type {string}
     * @memberof AdminGetCategories200ResponseDataInner
     */
    'slug'?: string;
    /**
     * The description of the category (optional).
     * @type {string}
     * @memberof AdminGetCategories200ResponseDataInner
     */
    'description'?: string | null;
    /**
     * The date and time when the category was created.
     * @type {string}
     * @memberof AdminGetCategories200ResponseDataInner
     */
    'createdAt'?: string;
    /**
     * The date and time when the category was last updated.
     * @type {string}
     * @memberof AdminGetCategories200ResponseDataInner
     */
    'updatedAt'?: string;
    /**
     * The date and time when the category was deleted (optional).
     * @type {string}
     * @memberof AdminGetCategories200ResponseDataInner
     */
    'deletedAt'?: string | null;
}
/**
 * 
 * @export
 * @interface AdminGetCategories200ResponsePagination
 */
export interface AdminGetCategories200ResponsePagination {
    /**
     * 
     * @type {number}
     * @memberof AdminGetCategories200ResponsePagination
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminGetCategories200ResponsePagination
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminGetCategories200ResponsePagination
     */
    'showPerPage'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminGetCategories200ResponsePagination
     */
    'totalCategories'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminGetCategories200ResponsePagination
     */
    'totalPages'?: number;
}
/**
 * 
 * @export
 * @interface AdminGetTags200Response
 */
export interface AdminGetTags200Response {
    /**
     * 
     * @type {Array<AdminCreateTag201ResponseTag>}
     * @memberof AdminGetTags200Response
     */
    'data'?: Array<AdminCreateTag201ResponseTag>;
    /**
     * 
     * @type {AdminGetTags200ResponsePagination}
     * @memberof AdminGetTags200Response
     */
    'pagination'?: AdminGetTags200ResponsePagination;
}
/**
 * 
 * @export
 * @interface AdminGetTags200ResponsePagination
 */
export interface AdminGetTags200ResponsePagination {
    /**
     * 
     * @type {number}
     * @memberof AdminGetTags200ResponsePagination
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminGetTags200ResponsePagination
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminGetTags200ResponsePagination
     */
    'showPerPage'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminGetTags200ResponsePagination
     */
    'totalTags'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminGetTags200ResponsePagination
     */
    'totalPages'?: number;
}
/**
 * 
 * @export
 * @interface AdminGetTagsRequest
 */
export interface AdminGetTagsRequest {
    /**
     * 
     * @type {number}
     * @memberof AdminGetTagsRequest
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminGetTagsRequest
     */
    'limit'?: number;
    /**
     * 
     * @type {string}
     * @memberof AdminGetTagsRequest
     */
    'search'?: string;
}
/**
 * 
 * @export
 * @interface AdminGetUsers200Response
 */
export interface AdminGetUsers200Response {
    /**
     * 
     * @type {Array<AdminGetUsers200ResponseDataInner>}
     * @memberof AdminGetUsers200Response
     */
    'data'?: Array<AdminGetUsers200ResponseDataInner>;
    /**
     * 
     * @type {AdminGetUsers200ResponsePagination}
     * @memberof AdminGetUsers200Response
     */
    'pagination'?: AdminGetUsers200ResponsePagination;
}
/**
 * 
 * @export
 * @interface AdminGetUsers200ResponseDataInner
 */
export interface AdminGetUsers200ResponseDataInner {
    /**
     * 
     * @type {string}
     * @memberof AdminGetUsers200ResponseDataInner
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminGetUsers200ResponseDataInner
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminGetUsers200ResponseDataInner
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminGetUsers200ResponseDataInner
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminGetUsers200ResponseDataInner
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminGetUsers200ResponseDataInner
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminGetUsers200ResponseDataInner
     */
    'phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminGetUsers200ResponseDataInner
     */
    'role'?: string;
}
/**
 * 
 * @export
 * @interface AdminGetUsers200ResponsePagination
 */
export interface AdminGetUsers200ResponsePagination {
    /**
     * 
     * @type {number}
     * @memberof AdminGetUsers200ResponsePagination
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminGetUsers200ResponsePagination
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminGetUsers200ResponsePagination
     */
    'showPerPage'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminGetUsers200ResponsePagination
     */
    'totalUsers'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminGetUsers200ResponsePagination
     */
    'totalPages'?: number;
}
/**
 * 
 * @export
 * @interface AdminGetUsers400Response
 */
export interface AdminGetUsers400Response {
    /**
     * 
     * @type {string}
     * @memberof AdminGetUsers400Response
     */
    'error'?: string;
    /**
     * 
     * @type {Array<AdminGetUsers400ResponseErrorsInner>}
     * @memberof AdminGetUsers400Response
     */
    'errors'?: Array<AdminGetUsers400ResponseErrorsInner>;
}
/**
 * 
 * @export
 * @interface AdminGetUsers400ResponseErrorsInner
 */
export interface AdminGetUsers400ResponseErrorsInner {
    /**
     * 
     * @type {string}
     * @memberof AdminGetUsers400ResponseErrorsInner
     */
    'path'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminGetUsers400ResponseErrorsInner
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface AdminGetUsersRequest
 */
export interface AdminGetUsersRequest {
    /**
     * 
     * @type {number}
     * @memberof AdminGetUsersRequest
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminGetUsersRequest
     */
    'limit'?: number;
    /**
     * 
     * @type {string}
     * @memberof AdminGetUsersRequest
     */
    'search'?: string;
}
/**
 * 
 * @export
 * @interface AdminUpdateCategory200Response
 */
export interface AdminUpdateCategory200Response {
    /**
     * 
     * @type {string}
     * @memberof AdminUpdateCategory200Response
     */
    'message'?: string;
    /**
     * 
     * @type {AdminCreateCategory201ResponseCategory}
     * @memberof AdminUpdateCategory200Response
     */
    'category'?: AdminCreateCategory201ResponseCategory;
}
/**
 * 
 * @export
 * @interface AdminUpdateCategoryRequest
 */
export interface AdminUpdateCategoryRequest {
    /**
     * The ID of the category to update.
     * @type {number}
     * @memberof AdminUpdateCategoryRequest
     */
    'id': number;
    /**
     * The name of the category.
     * @type {string}
     * @memberof AdminUpdateCategoryRequest
     */
    'name'?: string;
    /**
     * The unique slug for the category.
     * @type {string}
     * @memberof AdminUpdateCategoryRequest
     */
    'slug'?: string;
    /**
     * The description of the category (optional).
     * @type {string}
     * @memberof AdminUpdateCategoryRequest
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface AdminUpdateTag200Response
 */
export interface AdminUpdateTag200Response {
    /**
     * 
     * @type {string}
     * @memberof AdminUpdateTag200Response
     */
    'message'?: string;
    /**
     * 
     * @type {AdminCreateTag201ResponseTag}
     * @memberof AdminUpdateTag200Response
     */
    'tag'?: AdminCreateTag201ResponseTag;
}
/**
 * 
 * @export
 * @interface AdminUpdateTagRequest
 */
export interface AdminUpdateTagRequest {
    /**
     * The ID of the tag to update.
     * @type {number}
     * @memberof AdminUpdateTagRequest
     */
    'id': number;
    /**
     * The name of the tag.
     * @type {string}
     * @memberof AdminUpdateTagRequest
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface AdminUpdateUser200Response
 */
export interface AdminUpdateUser200Response {
    /**
     * 
     * @type {string}
     * @memberof AdminUpdateUser200Response
     */
    'message'?: string;
    /**
     * 
     * @type {AdminUpdateUser200ResponseUser}
     * @memberof AdminUpdateUser200Response
     */
    'user'?: AdminUpdateUser200ResponseUser;
}
/**
 * 
 * @export
 * @interface AdminUpdateUser200ResponseUser
 */
export interface AdminUpdateUser200ResponseUser {
    /**
     * 
     * @type {string}
     * @memberof AdminUpdateUser200ResponseUser
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminUpdateUser200ResponseUser
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminUpdateUser200ResponseUser
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminUpdateUser200ResponseUser
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminUpdateUser200ResponseUser
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminUpdateUser200ResponseUser
     */
    'phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminUpdateUser200ResponseUser
     */
    'role'?: AdminUpdateUser200ResponseUserRoleEnum;
    /**
     * 
     * @type {string}
     * @memberof AdminUpdateUser200ResponseUser
     */
    'country'?: string;
}

export const AdminUpdateUser200ResponseUserRoleEnum = {
    User: 'USER',
    Admin: 'ADMIN'
} as const;

export type AdminUpdateUser200ResponseUserRoleEnum = typeof AdminUpdateUser200ResponseUserRoleEnum[keyof typeof AdminUpdateUser200ResponseUserRoleEnum];

/**
 * 
 * @export
 * @interface AdminUpdateUser400Response
 */
export interface AdminUpdateUser400Response {
    /**
     * 
     * @type {string}
     * @memberof AdminUpdateUser400Response
     */
    'error'?: string;
    /**
     * 
     * @type {Array<AdminUpdateUser400ResponseErrorsInner>}
     * @memberof AdminUpdateUser400Response
     */
    'errors'?: Array<AdminUpdateUser400ResponseErrorsInner>;
}
/**
 * 
 * @export
 * @interface AdminUpdateUser400ResponseErrorsInner
 */
export interface AdminUpdateUser400ResponseErrorsInner {
    /**
     * 
     * @type {string}
     * @memberof AdminUpdateUser400ResponseErrorsInner
     */
    'path'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminUpdateUser400ResponseErrorsInner
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface AdminUpdateUser404Response
 */
export interface AdminUpdateUser404Response {
    /**
     * 
     * @type {string}
     * @memberof AdminUpdateUser404Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface AdminUpdateUser500Response
 */
export interface AdminUpdateUser500Response {
    /**
     * 
     * @type {string}
     * @memberof AdminUpdateUser500Response
     */
    'error'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminUpdateUser500Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface AdminUpdateUserRequest
 */
export interface AdminUpdateUserRequest {
    /**
     * The ID of the user to update.
     * @type {string}
     * @memberof AdminUpdateUserRequest
     */
    'id': string;
    /**
     * The email address of the user.
     * @type {string}
     * @memberof AdminUpdateUserRequest
     */
    'email'?: string;
    /**
     * The first name of the user.
     * @type {string}
     * @memberof AdminUpdateUserRequest
     */
    'firstName'?: string;
    /**
     * The last name of the user.
     * @type {string}
     * @memberof AdminUpdateUserRequest
     */
    'lastName'?: string;
    /**
     * The address of the user.
     * @type {string}
     * @memberof AdminUpdateUserRequest
     */
    'address'?: string;
    /**
     * The phone number of the user.
     * @type {string}
     * @memberof AdminUpdateUserRequest
     */
    'phone'?: string;
    /**
     * The role of the user.
     * @type {string}
     * @memberof AdminUpdateUserRequest
     */
    'role'?: AdminUpdateUserRequestRoleEnum;
    /**
     * The country of the user.
     * @type {string}
     * @memberof AdminUpdateUserRequest
     */
    'country'?: string;
}

export const AdminUpdateUserRequestRoleEnum = {
    User: 'user',
    Admin: 'admin'
} as const;

export type AdminUpdateUserRequestRoleEnum = typeof AdminUpdateUserRequestRoleEnum[keyof typeof AdminUpdateUserRequestRoleEnum];

/**
 * 
 * @export
 * @interface ChangePassword400Response
 */
export interface ChangePassword400Response {
    /**
     * 
     * @type {string}
     * @memberof ChangePassword400Response
     */
    'error'?: string;
    /**
     * 
     * @type {Array<ChangePassword400ResponseDetailsInner>}
     * @memberof ChangePassword400Response
     */
    'details'?: Array<ChangePassword400ResponseDetailsInner>;
}
/**
 * 
 * @export
 * @interface ChangePassword400ResponseDetailsInner
 */
export interface ChangePassword400ResponseDetailsInner {
    /**
     * 
     * @type {Array<string>}
     * @memberof ChangePassword400ResponseDetailsInner
     */
    'path'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ChangePassword400ResponseDetailsInner
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ChangePassword401Response
 */
export interface ChangePassword401Response {
    /**
     * 
     * @type {string}
     * @memberof ChangePassword401Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface ChangePasswordRequest
 */
export interface ChangePasswordRequest {
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordRequest
     */
    'oldPassword': string;
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordRequest
     */
    'newPassword': string;
}
/**
 * 
 * @export
 * @interface Created
 */
export interface Created {
    /**
     * 
     * @type {string}
     * @memberof Created
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface CreatedWithId
 */
export interface CreatedWithId {
    /**
     * 
     * @type {string}
     * @memberof CreatedWithId
     */
    'message': string;
    /**
     * 
     * @type {number}
     * @memberof CreatedWithId
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface ForbiddenError
 */
export interface ForbiddenError {
    /**
     * 
     * @type {string}
     * @memberof ForbiddenError
     */
    'error'?: string;
    /**
     * 
     * @type {string}
     * @memberof ForbiddenError
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ForgetPassword400Response
 */
export interface ForgetPassword400Response {
    /**
     * 
     * @type {string}
     * @memberof ForgetPassword400Response
     */
    'error'?: string;
    /**
     * 
     * @type {Array<ChangePassword400ResponseDetailsInner>}
     * @memberof ForgetPassword400Response
     */
    'details'?: Array<ChangePassword400ResponseDetailsInner>;
}
/**
 * 
 * @export
 * @interface ForgetPassword404Response
 */
export interface ForgetPassword404Response {
    /**
     * 
     * @type {string}
     * @memberof ForgetPassword404Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface ForgetPassword429Response
 */
export interface ForgetPassword429Response {
    /**
     * 
     * @type {string}
     * @memberof ForgetPassword429Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface ForgetPasswordRequest
 */
export interface ForgetPasswordRequest {
    /**
     * 
     * @type {string}
     * @memberof ForgetPasswordRequest
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface InternalServerError
 */
export interface InternalServerError {
    /**
     * 
     * @type {string}
     * @memberof InternalServerError
     */
    'error'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalServerError
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface NotFoundError
 */
export interface NotFoundError {
    /**
     * 
     * @type {string}
     * @memberof NotFoundError
     */
    'error'?: string;
    /**
     * 
     * @type {string}
     * @memberof NotFoundError
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface RegisterRequest
 */
export interface RegisterRequest {
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'gender': RegisterRequestGenderEnum;
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'confirmPassword': string;
}

export const RegisterRequestGenderEnum = {
    Male: 'male',
    Female: 'female',
    Other: 'other'
} as const;

export type RegisterRequestGenderEnum = typeof RegisterRequestGenderEnum[keyof typeof RegisterRequestGenderEnum];

/**
 * 
 * @export
 * @interface ResetPassword400Response
 */
export interface ResetPassword400Response {
    /**
     * 
     * @type {string}
     * @memberof ResetPassword400Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface ResetPasswordRequest
 */
export interface ResetPasswordRequest {
    /**
     * 
     * @type {string}
     * @memberof ResetPasswordRequest
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof ResetPasswordRequest
     */
    'newPassword': string;
}
/**
 * 
 * @export
 * @interface SubmitContactFormRequest
 */
export interface SubmitContactFormRequest {
    /**
     * The name of the company submitting the contact form.
     * @type {string}
     * @memberof SubmitContactFormRequest
     */
    'companyName': string;
    /**
     * The name of the contact person submitting the form.
     * @type {string}
     * @memberof SubmitContactFormRequest
     */
    'contactName': string;
    /**
     * The email address of the contact person.
     * @type {string}
     * @memberof SubmitContactFormRequest
     */
    'email': string;
    /**
     * The phone number of the contact person.
     * @type {string}
     * @memberof SubmitContactFormRequest
     */
    'phone': string;
    /**
     * The content of the inquiry or message.
     * @type {string}
     * @memberof SubmitContactFormRequest
     */
    'inquiry': string;
    /**
     * Indicates whether the user agrees to the privacy policy.
     * @type {boolean}
     * @memberof SubmitContactFormRequest
     */
    'privacyPolicy': boolean;
}
/**
 * 
 * @export
 * @interface Success
 */
export interface Success {
    /**
     * 
     * @type {string}
     * @memberof Success
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface UnAuthorizedError
 */
export interface UnAuthorizedError {
    /**
     * 
     * @type {string}
     * @memberof UnAuthorizedError
     */
    'error'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnAuthorizedError
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface UnprocessableEntity
 */
export interface UnprocessableEntity {
    /**
     * 
     * @type {string}
     * @memberof UnprocessableEntity
     */
    'error'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnprocessableEntity
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'error'?: string;
    /**
     * 
     * @type {Array<ValidationErrorErrorsInner>}
     * @memberof ValidationError
     */
    'errors'?: Array<ValidationErrorErrorsInner>;
}
/**
 * 
 * @export
 * @interface ValidationErrorErrorsInner
 */
export interface ValidationErrorErrorsInner {
    /**
     * 
     * @type {string}
     * @memberof ValidationErrorErrorsInner
     */
    'path'?: string;
    /**
     * 
     * @type {string}
     * @memberof ValidationErrorErrorsInner
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface VerifyEmail400Response
 */
export interface VerifyEmail400Response {
    /**
     * 
     * @type {string}
     * @memberof VerifyEmail400Response
     */
    'error'?: string;
    /**
     * 
     * @type {string}
     * @memberof VerifyEmail400Response
     */
    'message'?: string;
}

/**
 * AdminApi - axios parameter creator
 * @export
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new category with a unique name and slug.
         * @summary Create a new category
         * @param {AdminCreateCategoryRequest} adminCreateCategoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCreateCategory: async (adminCreateCategoryRequest: AdminCreateCategoryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminCreateCategoryRequest' is not null or undefined
            assertParamExists('adminCreateCategory', 'adminCreateCategoryRequest', adminCreateCategoryRequest)
            const localVarPath = `/api/admin/categories/create-category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminCreateCategoryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new tag with a unique name.
         * @summary Create a new tag
         * @param {AdminCreateTagRequest} adminCreateTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCreateTag: async (adminCreateTagRequest: AdminCreateTagRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminCreateTagRequest' is not null or undefined
            assertParamExists('adminCreateTag', 'adminCreateTagRequest', adminCreateTagRequest)
            const localVarPath = `/api/admin/tags/create-tag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminCreateTagRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new user, hashes their password, generates an email verification token, and sends a verification email.
         * @summary Register a new user
         * @param {AdminCreateUserRequest} adminCreateUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCreateUser: async (adminCreateUserRequest: AdminCreateUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminCreateUserRequest' is not null or undefined
            assertParamExists('adminCreateUser', 'adminCreateUserRequest', adminCreateUserRequest)
            const localVarPath = `/api/admin/users/create-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminCreateUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes categories by their IDs (soft delete, sets deletedAt).
         * @summary Delete categories by IDs
         * @param {AdminDeleteCategoriesRequest} adminDeleteCategoriesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteCategories: async (adminDeleteCategoriesRequest: AdminDeleteCategoriesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminDeleteCategoriesRequest' is not null or undefined
            assertParamExists('adminDeleteCategories', 'adminDeleteCategoriesRequest', adminDeleteCategoriesRequest)
            const localVarPath = `/api/admin/categories/delete-category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminDeleteCategoriesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes tags by their IDs (soft delete, sets deletedAt).
         * @summary Delete tags by IDs
         * @param {AdminDeleteCategoriesRequest} adminDeleteCategoriesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteTags: async (adminDeleteCategoriesRequest: AdminDeleteCategoriesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminDeleteCategoriesRequest' is not null or undefined
            assertParamExists('adminDeleteTags', 'adminDeleteCategoriesRequest', adminDeleteCategoriesRequest)
            const localVarPath = `/api/admin/tags/delete-tag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminDeleteCategoriesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Admin can delete user accounts including their own, but not other admins.
         * @summary Delete users by IDs
         * @param {AdminDeleteUsersRequest} adminDeleteUsersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteUsers: async (adminDeleteUsersRequest: AdminDeleteUsersRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminDeleteUsersRequest' is not null or undefined
            assertParamExists('adminDeleteUsers', 'adminDeleteUsersRequest', adminDeleteUsersRequest)
            const localVarPath = `/api/admin/users/delete-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminDeleteUsersRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves categories from the database with pagination and optional search using query parameters.
         * @summary Fetch categories with pagination and search
         * @param {number} page The page number for pagination.
         * @param {number} limit The number of categories to return per page.
         * @param {string} [search] Optional search term to filter categories by name or description.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminGetCategories: async (page: number, limit: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'page' is not null or undefined
            assertParamExists('adminGetCategories', 'page', page)
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('adminGetCategories', 'limit', limit)
            const localVarPath = `/api/admin/categories/get-category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves tags from the database with pagination and optional search.
         * @summary Fetch tags with pagination and search
         * @param {AdminGetTagsRequest} adminGetTagsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminGetTags: async (adminGetTagsRequest: AdminGetTagsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminGetTagsRequest' is not null or undefined
            assertParamExists('adminGetTags', 'adminGetTagsRequest', adminGetTagsRequest)
            const localVarPath = `/api/admin/tags/get-tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminGetTagsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves users from the database with pagination and optional search.
         * @summary Fetch users with pagination and search
         * @param {AdminGetUsersRequest} adminGetUsersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminGetUsers: async (adminGetUsersRequest: AdminGetUsersRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminGetUsersRequest' is not null or undefined
            assertParamExists('adminGetUsers', 'adminGetUsersRequest', adminGetUsersRequest)
            const localVarPath = `/api/admin/users/get-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminGetUsersRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates details of an existing category based on the provided category ID.
         * @summary Update category details
         * @param {AdminUpdateCategoryRequest} adminUpdateCategoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpdateCategory: async (adminUpdateCategoryRequest: AdminUpdateCategoryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminUpdateCategoryRequest' is not null or undefined
            assertParamExists('adminUpdateCategory', 'adminUpdateCategoryRequest', adminUpdateCategoryRequest)
            const localVarPath = `/api/admin/categories/update-category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminUpdateCategoryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates details of an existing tag based on the provided tag ID.
         * @summary Update tag details
         * @param {AdminUpdateTagRequest} adminUpdateTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpdateTag: async (adminUpdateTagRequest: AdminUpdateTagRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminUpdateTagRequest' is not null or undefined
            assertParamExists('adminUpdateTag', 'adminUpdateTagRequest', adminUpdateTagRequest)
            const localVarPath = `/api/admin/tags/update-tag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminUpdateTagRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update details of an existing user based on the provided user ID.
         * @summary Update user details
         * @param {AdminUpdateUserRequest} adminUpdateUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpdateUser: async (adminUpdateUserRequest: AdminUpdateUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminUpdateUserRequest' is not null or undefined
            assertParamExists('adminUpdateUser', 'adminUpdateUserRequest', adminUpdateUserRequest)
            const localVarPath = `/api/admin/users/update-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminUpdateUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminApi - functional programming interface
 * @export
 */
export const AdminApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new category with a unique name and slug.
         * @summary Create a new category
         * @param {AdminCreateCategoryRequest} adminCreateCategoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminCreateCategory(adminCreateCategoryRequest: AdminCreateCategoryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminCreateCategory201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminCreateCategory(adminCreateCategoryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminCreateCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new tag with a unique name.
         * @summary Create a new tag
         * @param {AdminCreateTagRequest} adminCreateTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminCreateTag(adminCreateTagRequest: AdminCreateTagRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminCreateTag201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminCreateTag(adminCreateTagRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminCreateTag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new user, hashes their password, generates an email verification token, and sends a verification email.
         * @summary Register a new user
         * @param {AdminCreateUserRequest} adminCreateUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminCreateUser(adminCreateUserRequest: AdminCreateUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Created>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminCreateUser(adminCreateUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminCreateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes categories by their IDs (soft delete, sets deletedAt).
         * @summary Delete categories by IDs
         * @param {AdminDeleteCategoriesRequest} adminDeleteCategoriesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminDeleteCategories(adminDeleteCategoriesRequest: AdminDeleteCategoriesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminDeleteCategories(adminDeleteCategoriesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminDeleteCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes tags by their IDs (soft delete, sets deletedAt).
         * @summary Delete tags by IDs
         * @param {AdminDeleteCategoriesRequest} adminDeleteCategoriesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminDeleteTags(adminDeleteCategoriesRequest: AdminDeleteCategoriesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminDeleteTags(adminDeleteCategoriesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminDeleteTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Admin can delete user accounts including their own, but not other admins.
         * @summary Delete users by IDs
         * @param {AdminDeleteUsersRequest} adminDeleteUsersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminDeleteUsers(adminDeleteUsersRequest: AdminDeleteUsersRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminDeleteUsers(adminDeleteUsersRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminDeleteUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves categories from the database with pagination and optional search using query parameters.
         * @summary Fetch categories with pagination and search
         * @param {number} page The page number for pagination.
         * @param {number} limit The number of categories to return per page.
         * @param {string} [search] Optional search term to filter categories by name or description.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminGetCategories(page: number, limit: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminGetCategories200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminGetCategories(page, limit, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminGetCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves tags from the database with pagination and optional search.
         * @summary Fetch tags with pagination and search
         * @param {AdminGetTagsRequest} adminGetTagsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminGetTags(adminGetTagsRequest: AdminGetTagsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminGetTags200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminGetTags(adminGetTagsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminGetTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves users from the database with pagination and optional search.
         * @summary Fetch users with pagination and search
         * @param {AdminGetUsersRequest} adminGetUsersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminGetUsers(adminGetUsersRequest: AdminGetUsersRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminGetUsers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminGetUsers(adminGetUsersRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminGetUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates details of an existing category based on the provided category ID.
         * @summary Update category details
         * @param {AdminUpdateCategoryRequest} adminUpdateCategoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUpdateCategory(adminUpdateCategoryRequest: AdminUpdateCategoryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminUpdateCategory200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUpdateCategory(adminUpdateCategoryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminUpdateCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates details of an existing tag based on the provided tag ID.
         * @summary Update tag details
         * @param {AdminUpdateTagRequest} adminUpdateTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUpdateTag(adminUpdateTagRequest: AdminUpdateTagRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminUpdateTag200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUpdateTag(adminUpdateTagRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminUpdateTag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update details of an existing user based on the provided user ID.
         * @summary Update user details
         * @param {AdminUpdateUserRequest} adminUpdateUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUpdateUser(adminUpdateUserRequest: AdminUpdateUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminUpdateUser200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUpdateUser(adminUpdateUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminUpdateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminApi - factory interface
 * @export
 */
export const AdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminApiFp(configuration)
    return {
        /**
         * Creates a new category with a unique name and slug.
         * @summary Create a new category
         * @param {AdminCreateCategoryRequest} adminCreateCategoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCreateCategory(adminCreateCategoryRequest: AdminCreateCategoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<AdminCreateCategory201Response> {
            return localVarFp.adminCreateCategory(adminCreateCategoryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new tag with a unique name.
         * @summary Create a new tag
         * @param {AdminCreateTagRequest} adminCreateTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCreateTag(adminCreateTagRequest: AdminCreateTagRequest, options?: RawAxiosRequestConfig): AxiosPromise<AdminCreateTag201Response> {
            return localVarFp.adminCreateTag(adminCreateTagRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new user, hashes their password, generates an email verification token, and sends a verification email.
         * @summary Register a new user
         * @param {AdminCreateUserRequest} adminCreateUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCreateUser(adminCreateUserRequest: AdminCreateUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<Created> {
            return localVarFp.adminCreateUser(adminCreateUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes categories by their IDs (soft delete, sets deletedAt).
         * @summary Delete categories by IDs
         * @param {AdminDeleteCategoriesRequest} adminDeleteCategoriesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteCategories(adminDeleteCategoriesRequest: AdminDeleteCategoriesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Success> {
            return localVarFp.adminDeleteCategories(adminDeleteCategoriesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes tags by their IDs (soft delete, sets deletedAt).
         * @summary Delete tags by IDs
         * @param {AdminDeleteCategoriesRequest} adminDeleteCategoriesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteTags(adminDeleteCategoriesRequest: AdminDeleteCategoriesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Success> {
            return localVarFp.adminDeleteTags(adminDeleteCategoriesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Admin can delete user accounts including their own, but not other admins.
         * @summary Delete users by IDs
         * @param {AdminDeleteUsersRequest} adminDeleteUsersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteUsers(adminDeleteUsersRequest: AdminDeleteUsersRequest, options?: RawAxiosRequestConfig): AxiosPromise<Success> {
            return localVarFp.adminDeleteUsers(adminDeleteUsersRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves categories from the database with pagination and optional search using query parameters.
         * @summary Fetch categories with pagination and search
         * @param {number} page The page number for pagination.
         * @param {number} limit The number of categories to return per page.
         * @param {string} [search] Optional search term to filter categories by name or description.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminGetCategories(page: number, limit: number, search?: string, options?: RawAxiosRequestConfig): AxiosPromise<AdminGetCategories200Response> {
            return localVarFp.adminGetCategories(page, limit, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves tags from the database with pagination and optional search.
         * @summary Fetch tags with pagination and search
         * @param {AdminGetTagsRequest} adminGetTagsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminGetTags(adminGetTagsRequest: AdminGetTagsRequest, options?: RawAxiosRequestConfig): AxiosPromise<AdminGetTags200Response> {
            return localVarFp.adminGetTags(adminGetTagsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves users from the database with pagination and optional search.
         * @summary Fetch users with pagination and search
         * @param {AdminGetUsersRequest} adminGetUsersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminGetUsers(adminGetUsersRequest: AdminGetUsersRequest, options?: RawAxiosRequestConfig): AxiosPromise<AdminGetUsers200Response> {
            return localVarFp.adminGetUsers(adminGetUsersRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates details of an existing category based on the provided category ID.
         * @summary Update category details
         * @param {AdminUpdateCategoryRequest} adminUpdateCategoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpdateCategory(adminUpdateCategoryRequest: AdminUpdateCategoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<AdminUpdateCategory200Response> {
            return localVarFp.adminUpdateCategory(adminUpdateCategoryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates details of an existing tag based on the provided tag ID.
         * @summary Update tag details
         * @param {AdminUpdateTagRequest} adminUpdateTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpdateTag(adminUpdateTagRequest: AdminUpdateTagRequest, options?: RawAxiosRequestConfig): AxiosPromise<AdminUpdateTag200Response> {
            return localVarFp.adminUpdateTag(adminUpdateTagRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update details of an existing user based on the provided user ID.
         * @summary Update user details
         * @param {AdminUpdateUserRequest} adminUpdateUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpdateUser(adminUpdateUserRequest: AdminUpdateUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<AdminUpdateUser200Response> {
            return localVarFp.adminUpdateUser(adminUpdateUserRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */
export class AdminApi extends BaseAPI {
    /**
     * Creates a new category with a unique name and slug.
     * @summary Create a new category
     * @param {AdminCreateCategoryRequest} adminCreateCategoryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminCreateCategory(adminCreateCategoryRequest: AdminCreateCategoryRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminCreateCategory(adminCreateCategoryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new tag with a unique name.
     * @summary Create a new tag
     * @param {AdminCreateTagRequest} adminCreateTagRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminCreateTag(adminCreateTagRequest: AdminCreateTagRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminCreateTag(adminCreateTagRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new user, hashes their password, generates an email verification token, and sends a verification email.
     * @summary Register a new user
     * @param {AdminCreateUserRequest} adminCreateUserRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminCreateUser(adminCreateUserRequest: AdminCreateUserRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminCreateUser(adminCreateUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes categories by their IDs (soft delete, sets deletedAt).
     * @summary Delete categories by IDs
     * @param {AdminDeleteCategoriesRequest} adminDeleteCategoriesRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminDeleteCategories(adminDeleteCategoriesRequest: AdminDeleteCategoriesRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminDeleteCategories(adminDeleteCategoriesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes tags by their IDs (soft delete, sets deletedAt).
     * @summary Delete tags by IDs
     * @param {AdminDeleteCategoriesRequest} adminDeleteCategoriesRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminDeleteTags(adminDeleteCategoriesRequest: AdminDeleteCategoriesRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminDeleteTags(adminDeleteCategoriesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Admin can delete user accounts including their own, but not other admins.
     * @summary Delete users by IDs
     * @param {AdminDeleteUsersRequest} adminDeleteUsersRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminDeleteUsers(adminDeleteUsersRequest: AdminDeleteUsersRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminDeleteUsers(adminDeleteUsersRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves categories from the database with pagination and optional search using query parameters.
     * @summary Fetch categories with pagination and search
     * @param {number} page The page number for pagination.
     * @param {number} limit The number of categories to return per page.
     * @param {string} [search] Optional search term to filter categories by name or description.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminGetCategories(page: number, limit: number, search?: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminGetCategories(page, limit, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves tags from the database with pagination and optional search.
     * @summary Fetch tags with pagination and search
     * @param {AdminGetTagsRequest} adminGetTagsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminGetTags(adminGetTagsRequest: AdminGetTagsRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminGetTags(adminGetTagsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves users from the database with pagination and optional search.
     * @summary Fetch users with pagination and search
     * @param {AdminGetUsersRequest} adminGetUsersRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminGetUsers(adminGetUsersRequest: AdminGetUsersRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminGetUsers(adminGetUsersRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates details of an existing category based on the provided category ID.
     * @summary Update category details
     * @param {AdminUpdateCategoryRequest} adminUpdateCategoryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminUpdateCategory(adminUpdateCategoryRequest: AdminUpdateCategoryRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminUpdateCategory(adminUpdateCategoryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates details of an existing tag based on the provided tag ID.
     * @summary Update tag details
     * @param {AdminUpdateTagRequest} adminUpdateTagRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminUpdateTag(adminUpdateTagRequest: AdminUpdateTagRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminUpdateTag(adminUpdateTagRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update details of an existing user based on the provided user ID.
     * @summary Update user details
     * @param {AdminUpdateUserRequest} adminUpdateUserRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminUpdateUser(adminUpdateUserRequest: AdminUpdateUserRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminUpdateUser(adminUpdateUserRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Allows an authenticated user to change their password by providing the old and new password.
         * @summary Change user password
         * @param {ChangePasswordRequest} changePasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword: async (changePasswordRequest: ChangePasswordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'changePasswordRequest' is not null or undefined
            assertParamExists('changePassword', 'changePasswordRequest', changePasswordRequest)
            const localVarPath = `/api/auth/change-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changePasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends a reset password email with a secure token link. Each user is allowed a maximum of 3 emails per hour.
         * @summary Send a password reset email
         * @param {ForgetPasswordRequest} forgetPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgetPassword: async (forgetPasswordRequest: ForgetPasswordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'forgetPasswordRequest' is not null or undefined
            assertParamExists('forgetPassword', 'forgetPasswordRequest', forgetPasswordRequest)
            const localVarPath = `/api/auth/forget-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(forgetPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new user, hashes their password, generates an email verification token, and sends a verification email.
         * @summary Register a new user
         * @param {RegisterRequest} registerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register: async (registerRequest: RegisterRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerRequest' is not null or undefined
            assertParamExists('register', 'registerRequest', registerRequest)
            const localVarPath = `/api/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resets the user\'s password using a provided reset token and new password. The reset token is invalidated after the reset.
         * @summary Reset password for a user
         * @param {ResetPasswordRequest} resetPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword: async (resetPasswordRequest: ResetPasswordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resetPasswordRequest' is not null or undefined
            assertParamExists('resetPassword', 'resetPasswordRequest', resetPasswordRequest)
            const localVarPath = `/api/reset-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint sends a verification email to the user with the provided email address.
         * @summary Send verification email to a registered user
         * @param {ForgetPasswordRequest} forgetPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendVerificationEmail: async (forgetPasswordRequest: ForgetPasswordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'forgetPasswordRequest' is not null or undefined
            assertParamExists('sendVerificationEmail', 'forgetPasswordRequest', forgetPasswordRequest)
            const localVarPath = `/api/auth/verify-email-request`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(forgetPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verifies the user\'s email address using a provided verification token. Marks the user\'s email as verified in the database.
         * @summary Verify user email
         * @param {string} token The email verification token sent to the user\&#39;s email address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmail: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('verifyEmail', 'token', token)
            const localVarPath = `/api/auth/verify-email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Allows an authenticated user to change their password by providing the old and new password.
         * @summary Change user password
         * @param {ChangePasswordRequest} changePasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changePassword(changePasswordRequest: ChangePasswordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changePassword(changePasswordRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.changePassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sends a reset password email with a secure token link. Each user is allowed a maximum of 3 emails per hour.
         * @summary Send a password reset email
         * @param {ForgetPasswordRequest} forgetPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forgetPassword(forgetPasswordRequest: ForgetPasswordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forgetPassword(forgetPasswordRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.forgetPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new user, hashes their password, generates an email verification token, and sends a verification email.
         * @summary Register a new user
         * @param {RegisterRequest} registerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async register(registerRequest: RegisterRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Created>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.register(registerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.register']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resets the user\'s password using a provided reset token and new password. The reset token is invalidated after the reset.
         * @summary Reset password for a user
         * @param {ResetPasswordRequest} resetPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetPassword(resetPasswordRequest: ResetPasswordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetPassword(resetPasswordRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.resetPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint sends a verification email to the user with the provided email address.
         * @summary Send verification email to a registered user
         * @param {ForgetPasswordRequest} forgetPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendVerificationEmail(forgetPasswordRequest: ForgetPasswordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendVerificationEmail(forgetPasswordRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.sendVerificationEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Verifies the user\'s email address using a provided verification token. Marks the user\'s email as verified in the database.
         * @summary Verify user email
         * @param {string} token The email verification token sent to the user\&#39;s email address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyEmail(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyEmail(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.verifyEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Allows an authenticated user to change their password by providing the old and new password.
         * @summary Change user password
         * @param {ChangePasswordRequest} changePasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(changePasswordRequest: ChangePasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<Success> {
            return localVarFp.changePassword(changePasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends a reset password email with a secure token link. Each user is allowed a maximum of 3 emails per hour.
         * @summary Send a password reset email
         * @param {ForgetPasswordRequest} forgetPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgetPassword(forgetPasswordRequest: ForgetPasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<Success> {
            return localVarFp.forgetPassword(forgetPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new user, hashes their password, generates an email verification token, and sends a verification email.
         * @summary Register a new user
         * @param {RegisterRequest} registerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(registerRequest: RegisterRequest, options?: RawAxiosRequestConfig): AxiosPromise<Created> {
            return localVarFp.register(registerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Resets the user\'s password using a provided reset token and new password. The reset token is invalidated after the reset.
         * @summary Reset password for a user
         * @param {ResetPasswordRequest} resetPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword(resetPasswordRequest: ResetPasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<Success> {
            return localVarFp.resetPassword(resetPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint sends a verification email to the user with the provided email address.
         * @summary Send verification email to a registered user
         * @param {ForgetPasswordRequest} forgetPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendVerificationEmail(forgetPasswordRequest: ForgetPasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<Success> {
            return localVarFp.sendVerificationEmail(forgetPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Verifies the user\'s email address using a provided verification token. Marks the user\'s email as verified in the database.
         * @summary Verify user email
         * @param {string} token The email verification token sent to the user\&#39;s email address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmail(token: string, options?: RawAxiosRequestConfig): AxiosPromise<Success> {
            return localVarFp.verifyEmail(token, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Allows an authenticated user to change their password by providing the old and new password.
     * @summary Change user password
     * @param {ChangePasswordRequest} changePasswordRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public changePassword(changePasswordRequest: ChangePasswordRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).changePassword(changePasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sends a reset password email with a secure token link. Each user is allowed a maximum of 3 emails per hour.
     * @summary Send a password reset email
     * @param {ForgetPasswordRequest} forgetPasswordRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public forgetPassword(forgetPasswordRequest: ForgetPasswordRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).forgetPassword(forgetPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new user, hashes their password, generates an email verification token, and sends a verification email.
     * @summary Register a new user
     * @param {RegisterRequest} registerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public register(registerRequest: RegisterRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).register(registerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resets the user\'s password using a provided reset token and new password. The reset token is invalidated after the reset.
     * @summary Reset password for a user
     * @param {ResetPasswordRequest} resetPasswordRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public resetPassword(resetPasswordRequest: ResetPasswordRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).resetPassword(resetPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint sends a verification email to the user with the provided email address.
     * @summary Send verification email to a registered user
     * @param {ForgetPasswordRequest} forgetPasswordRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public sendVerificationEmail(forgetPasswordRequest: ForgetPasswordRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).sendVerificationEmail(forgetPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verifies the user\'s email address using a provided verification token. Marks the user\'s email as verified in the database.
     * @summary Verify user email
     * @param {string} token The email verification token sent to the user\&#39;s email address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public verifyEmail(token: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).verifyEmail(token, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContactApi - axios parameter creator
 * @export
 */
export const ContactApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Submits a contact form with company details, contact information, and inquiry content. Stores the submission in the database and optionally sends a confirmation email.
         * @summary Submit a contact form inquiry
         * @param {SubmitContactFormRequest} submitContactFormRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitContactForm: async (submitContactFormRequest: SubmitContactFormRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'submitContactFormRequest' is not null or undefined
            assertParamExists('submitContactForm', 'submitContactFormRequest', submitContactFormRequest)
            const localVarPath = `/api/contact`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(submitContactFormRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContactApi - functional programming interface
 * @export
 */
export const ContactApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContactApiAxiosParamCreator(configuration)
    return {
        /**
         * Submits a contact form with company details, contact information, and inquiry content. Stores the submission in the database and optionally sends a confirmation email.
         * @summary Submit a contact form inquiry
         * @param {SubmitContactFormRequest} submitContactFormRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitContactForm(submitContactFormRequest: SubmitContactFormRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Created>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitContactForm(submitContactFormRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactApi.submitContactForm']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContactApi - factory interface
 * @export
 */
export const ContactApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContactApiFp(configuration)
    return {
        /**
         * Submits a contact form with company details, contact information, and inquiry content. Stores the submission in the database and optionally sends a confirmation email.
         * @summary Submit a contact form inquiry
         * @param {SubmitContactFormRequest} submitContactFormRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitContactForm(submitContactFormRequest: SubmitContactFormRequest, options?: RawAxiosRequestConfig): AxiosPromise<Created> {
            return localVarFp.submitContactForm(submitContactFormRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContactApi - object-oriented interface
 * @export
 * @class ContactApi
 * @extends {BaseAPI}
 */
export class ContactApi extends BaseAPI {
    /**
     * Submits a contact form with company details, contact information, and inquiry content. Stores the submission in the database and optionally sends a confirmation email.
     * @summary Submit a contact form inquiry
     * @param {SubmitContactFormRequest} submitContactFormRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    public submitContactForm(submitContactFormRequest: SubmitContactFormRequest, options?: RawAxiosRequestConfig) {
        return ContactApiFp(this.configuration).submitContactForm(submitContactFormRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



